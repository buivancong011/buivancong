#!/usr/bin/env bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Tiền tố sing-box containers (đã có sẵn)
SBOX_PREFIX="csbox"

# Tiền tố UR containers
UR_PREFIX="ur-"

# Image theo repo techroy23
UR_IMAGE="ghcr.io/techroy23/docker-urnetwork:latest"

# ĐĂNG NHẬP MẶC ĐỊNH (có thể override bằng biến môi trường bên ngoài)
USER_AUTH="${USER_AUTH:-buivancong012@gmail.com}"
PASSWORD="${PASSWORD:-buivancong012}"

# (TUỲ CHỌN) Mount 1 proxy.txt chung cho TẤT CẢ ur-sboxN
# Định dạng mỗi dòng: ip:port:user:pass
PROXY_FILE="${PROXY_FILE:-}"  # ví dụ: /root/proxy.txt hoặc để rỗng

# Kéo image trước khi chạy?
PULL_ON_START=true

# Recreate container: always | changed
#  - always  : luôn rm & run lại mỗi lần up
#  - changed : chỉ recreate khi image ID đã đổi
RECREATE_MODE="changed"

# Thời gian chờ sbox lên running (giây)
WAIT_TIMEOUT=25

# Health/Logs
LOG_MAX_SIZE="10m"
LOG_MAX_FILE="3"

# Hiển thị device-name trên dashboard (giữ sboxN để dễ đối chiếu)
DEVICE_NAME_MODE="sbox"   # "sbox" | "ur" (image không có tham số device-name; dùng để gắn nhãn log)

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] Cần Docker."; exit 1; }

if [[ -n "$PROXY_FILE" && ! -f "$PROXY_FILE" ]]; then
  echo "[ERR] PROXY_FILE đã đặt nhưng không tồn tại: $PROXY_FILE"
  exit 1
fi

# ===================== FUNCS =====================
discover_sbox() {
  docker ps -a --format '{{.Names}}' | awk -v pfx="^${SBOX_PREFIX}[0-9]+$" '$0 ~ pfx' | sort -V
}

wait_running_sbox() {
  local name="$1" timeout="${2:-$WAIT_TIMEOUT}" t=0
  while :; do
    local st
    st="$(docker inspect -f '{{.State.Status}}' "$name" 2>/dev/null || true)"
    case "$st" in
      running) return 0 ;;
      restarting|created|starting)
        if (( t >= timeout )); then
          echo "[WARN] $name chưa running sau ${timeout}s (status=$st)."
          return 1
        fi
        sleep 1; ((t++))
        ;;
      exited|dead|'')
        echo "[ERR] $name status=$st. Không thể gắn UR vào."
        return 1
        ;;
      *) sleep 1 ;;
    esac
  done
}

mk_device_name() {
  local sbox="$1"
  case "$DEVICE_NAME_MODE" in
    sbox) echo "$sbox" ;;
    ur)   echo "ur${sbox#${SBOX_PREFIX}}" ;;
    *)    echo "$sbox" ;;
  esac
}

probe_network() {
  local s="$1"
  # Probe TCP (không cần DNS)
  if ! docker run --rm --network=container:"$s" \
       curlimages/curl:latest -s --connect-timeout 6 https://1.1.1.1 >/dev/null; then
    echo "   ⚠ ${s} chưa ra Internet (TCP)."
    return 1
  fi
  # Probe qua domain (có DNS)
  if ! docker run --rm --network=container:"$s" \
       curlimages/curl:latest -s --connect-timeout 6 https://www.cloudflare.com/cdn-cgi/trace >/dev/null; then
    echo "   ⚠ ${s} DNS/TLS chưa OK."
    return 1
  fi
  return 0
}

ensure_image() {
  if [[ "${PULL_ON_START}" == true ]]; then
    echo "[IMG] Pull ${UR_IMAGE} ..."
    docker pull "${UR_IMAGE}" >/dev/null || true
  fi
}

need_recreate() {
  local ur="$1"
  # Nếu container chưa tồn tại → cần tạo
  if ! docker ps -a --format '{{.Names}}' | grep -qx "$ur"; then
    return 0
  fi
  # always → recreate
  [[ "${RECREATE_MODE}" == "always" ]] && return 0

  # So ảnh hiện tại của container vs image local
  local cur_img_id new_img_id
  cur_img_id="$(docker inspect -f '{{.Image}}' "$ur" 2>/dev/null || echo '')"
  new_img_id="$(docker image inspect "${UR_IMAGE}" -f '{{.Id}}' 2>/dev/null || echo '')"
  [[ -z "$cur_img_id" || -z "$new_img_id" ]] && return 0

  if [[ "$cur_img_id" != "$new_img_id" ]]; then
    return 0   # image đã đổi
  fi
  return 1     # image giống nhau → giữ nguyên
}

start_ur_for_sbox() {
  local sbox="$1"
  local ur_name="${UR_PREFIX}${sbox}"
  local device_name; device_name="$(mk_device_name "$sbox")"

  echo "→ Chuẩn bị ${ur_name} (net=container:${sbox}, device=${device_name})"

  # Probe mạng trước
  if ! probe_network "$sbox"; then
    echo "   ⚠ Bỏ qua ${ur_name} vì route ${sbox} chưa thông."
    return 0
  fi

  # Volume vnStat riêng cho mỗi route (auto-create nếu chưa có)
  local vnstat_vol="vnstat_${sbox}"
  docker volume create "${vnstat_vol}" >/dev/null 2>&1 || true

  if need_recreate "${ur_name}"; then
    echo "   ↻ (Re)create ${ur_name} với image hiện tại"
    docker rm -f "${ur_name}" >/dev/null 2>&1 || true

    # Chuẩn bị args
    local run_args=(
      -d --name "${ur_name}"
      --network="container:${sbox}"
      --restart=always
      --log-opt "max-size=${LOG_MAX_SIZE}" --log-opt "max-file=${LOG_MAX_FILE}"
      -e USER_AUTH="${USER_AUTH}"
      -e PASSWORD="${PASSWORD}"
      -e ENABLE_IP_CHECKER=false
      -e TZ=Asia/Ho_Chi_Minh
      --health-cmd='wget -qO- --timeout=5 https://1.1.1.1 || exit 1'
      --health-interval=30s --health-retries=3 --health-timeout=8s
      -v "${vnstat_vol}:/var/lib/vnstat"
    )
    # Mount proxy.txt nếu có
    if [[ -n "$PROXY_FILE" ]]; then
      run_args+=(-v "${PROXY_FILE}:/app/proxy.txt:ro")
    fi

    docker run "${run_args[@]}" "${UR_IMAGE}" >/dev/null
    echo "   ✓ ${ur_name} đã (re)start  |  volume=${vnstat_vol}"
  else
    echo "   ✓ ${ur_name} đang dùng image mới nhất — giữ nguyên"
  fi
}

stop_ur_for_sbox() {
  local sbox="$1"
  local ur_name="${UR_PREFIX}${sbox}"
  docker rm -f "${ur_name}" >/dev/null 2>&1 && echo "✗ ${ur_name} đã xoá" || true
}

status_ur_for_sbox() {
  local sbox="$1"
  local ur_name="${UR_PREFIX}${sbox}"
  if docker ps -a --format '{{.Names}}\t{{.Status}}' | grep -q "^${ur_name}\b"; then
    docker ps -a --format '{{.Names}}\t{{.Status}}' | awk -v n="${ur_name}" '$1==n{print}'
  else
    echo "${ur_name}    (not found)"
  fi
}

logs_ur_for_sbox() {
  local sbox="$1"
  local ur_name="${UR_PREFIX}${sbox}"
  echo "===== ${ur_name} ====="
  docker logs --since=30m -n 200 "${ur_name}" || true
}

cmd_up() {
  ensure_image
  local list; list="$(discover_sbox)"
  if [[ -z "${list}" ]]; then
    echo "[ERR] Không tìm thấy ${SBOX_PREFIX}N nào. Hãy tạo sbox trước."
    exit 1
  fi

  echo "[INFO] Phát hiện routes:"
  echo "${list}" | xargs -I{} echo " - {}"

  echo
  echo "[INFO] Kiểm tra trạng thái sbox..."
  while read -r s; do
    wait_running_sbox "$s" "$WAIT_TIMEOUT" || echo "   ⚠ Bỏ qua ${s} (chưa running)."
  done <<< "${list}"

  echo
  echo "[INFO] Khởi chạy UR cho từng route:"
  while read -r s; do
    if docker inspect -f '{{.State.Status}}' "$s" >/dev/null 2>&1 && \
       [[ "$(docker inspect -f '{{.State.Status}}' "$s")" == "running" ]]; then
      start_ur_for_sbox "$s"
    else
      echo "   ⚠ Bỏ qua ${s} (không running)."
    fi
  done <<< "${list}"

  echo
  echo "✅ Hoàn tất. Dùng:  $0 status   để xem trạng thái."
}

cmd_down() {
  docker ps -a --format '{{.Names}}' | awk -v pfx="^${UR_PREFIX}${SBOX_PREFIX}[0-9]+$" '$0 ~ pfx' \
    | while read -r ur; do docker rm -f "$ur" >/dev/null 2>&1 && echo "✗ $ur đã xoá" || true; done
  echo "[DONE] Đã dừng toàn bộ UR gắn với sbox."
}

cmd_status() {
  local list; list="$(discover_sbox)"
  if [[ -z "${list}" ]]; then
    echo "[INFO] Không thấy ${SBOX_PREFIX}N nào."
    exit 0
  fi
  echo "[STATUS] sbox & ur-sbox:"
  while read -r s; do
    local st; st="$(docker inspect -f '{{.State.Status}}' "$s" 2>/dev/null || echo "unknown")"
    printf "%-8s: %s\n" "$s" "$st"
    status_ur_for_sbox "$s"
  done <<< "${list}"
}

cmd_logs() {
  local list; list="$(discover_sbox)"
  if [[ -z "${list}" ]]; then
    echo "[INFO] Không thấy ${SBOX_PREFIX}N nào."
    exit 0
  fi
  while read -r s; do
    logs_ur_for_sbox "$s"
  done <<< "${list}"
}

# ===================== CLI =====================
case "${1:-up}" in
  up)      cmd_up ;;
  down)    cmd_down ;;
  status)  cmd_status ;;
  logs)    cmd_logs ;;
  *) echo "Usage: $0 [up|down|status|logs]"; exit 1 ;;
esac
