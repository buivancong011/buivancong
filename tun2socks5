#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Danh s√°ch proxy SOCKS5 (khuy·∫øn ngh·ªã socks5h:// ƒë·ªÉ √©p DNS qua proxy)
# H·ªó tr·ª£:
#   - socks5h://IP:PORT
#   - socks5h://user:pass@IP:PORT
#   - socks5://... (v·∫´n ƒë∆∞·ª£c, nh∆∞ng socks5h ƒë·∫£m b·∫£o DNS qua proxy)
UPSTREAMS=(
  "socks5h://156.239.204.25:1339"
  # "socks5h://user:pass@IP:PORT"
  # th√™m c√°c proxy kh√°c...
)

TUN_NAME_BASE="tun"                       # t√™n container base: tun1, tun2, ...
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"      # image tun2socks
TUN_LOGLEVEL="info"                       # debug|info|warn|error
TUN_MTU=""                                # v√≠ d·ª• "1400" n·∫øu hay timeout
TUN_RESOLVER="1.1.1.1"                    # 8.8.8.8 / 9.9.9.9 ƒë·ªÅu OK

# Probe (l·ªçc proxy ch·∫øt tr∆∞·ªõc khi t·∫°o route)
PROBE_MAX_RETRY=1                         # t·ªïng (1 + PROBE_MAX_RETRY) l·∫ßn th·ª≠
PROBE_TIMEOUT=8                           # gi√¢y

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] C·∫ßn Docker."; exit 1; }

if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] T·∫°o /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

# ===================== HELPERS =====================
validate_socks() {
  local u="$1"
  # ch·∫•p nh·∫≠n socks5:// ho·∫∑c socks5h://, c√≥/kh√¥ng user:pass
  [[ "$u" =~ ^socks5(h)?://([^/@:]+:[^/@]+@)?([0-9]{1,3}\.){3}[0-9]{1,3}:[0-9]+$ ]]
}

probe_proxy_once() {
  local u="$1"
  # d√πng HEAD t·ªõi Google; socks5h s·∫Ω ki·ªÉm tra c·∫£ DNS qua proxy
  curl -sSx "$u" -I "https://www.google.com" --max-time "$PROBE_TIMEOUT" >/dev/null 2>&1
}

probe_proxy() {
  local u="$1"
  local i
  for ((i=0; i<=PROBE_MAX_RETRY; i++)); do
    if probe_proxy_once "$u"; then return 0; fi
    sleep 1
  done
  return 1
}

wait_until_running() {
  local name="$1"
  local timeout="${2:-25}" # gi√¢y
  local i=0 st="missing"
  while (( i < timeout )); do
    st="$(docker inspect -f '{{.State.Status}}' "$name" 2>/dev/null || echo "missing")"
    if [[ "$st" == "running" ]]; then return 0; fi
    sleep 1
    ((i++))
  done
  echo "[WAIT] $name ch∆∞a running (status: $st)"
  return 1
}

cleanup_route() {
  local idx="$1"
  docker rm -f "${TUN_NAME_BASE}${idx}" >/dev/null 2>&1 || true
  rm -f "resolv_${idx}.conf" || true
}

# ===================== CORE =====================
start_route() {
  local idx="$1"
  local upstream="$2"
  local t="${TUN_NAME_BASE}${idx}"
  local resolv_file="resolv_${idx}.conf"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $upstream"

  # 0) Validate
  if ! validate_socks "$upstream"; then
    echo "[ROUTE $idx] ‚ùå URL kh√¥ng h·ª£p l·ªá ‚Üí b·ªè qua."
    return 0
  fi

  # 1) Probe (l·ªçc proxy ch·∫øt)
  if ! probe_proxy "$upstream"; then
    echo "[ROUTE $idx] ‚ùå Proxy kh√¥ng ph·∫£n h·ªìi (probe fail) ‚Üí b·ªè qua."
    return 0
  fi

  # 2) Cleanup c≈©
  cleanup_route "$idx"

  # 3) resolv.conf trong namespace tun
  #    - use-vc: √©p DNS qua TCP ƒë·ªÉ tr√°nh l·ªói UDP/ASSOCIATE tr√™n nhi·ªÅu SOCKS5
  #    - attempts/timeout: gi·∫£m treo
  cat > "$resolv_file" <<EOF
options ndots:0
options use-vc
options attempts:2
options timeout:3
nameserver ${TUN_RESOLVER}
EOF

  # 4) Ch·∫°y tun2socks
  #    EXTRA_COMMANDS="" ‚Üí KH√îNG bypass UDP/53; DNS ƒëi theo ƒë∆∞·ªùng tun/proxy
  echo "[ROUTE $idx] Kh·ªüi ch·∫°y tun2socks..."
  docker run -d --name "$t" --restart=always \
    --cap-add=NET_ADMIN \
    -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/$resolv_file":/etc/resolv.conf:ro \
    -e PROXY="$upstream" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="" \
    "$IMG_TUN" >/dev/null || { echo "[ROUTE $idx] ‚ùå L·ªói kh·ªüi ch·∫°y"; return 0; }

  # 5) ƒê·ª£i container running
  if ! wait_until_running "$t" 25; then
    echo "[ROUTE $idx] ‚ùå Container ch∆∞a s·∫µn s√†ng. Log g·∫ßn ƒë√¢y:"
    docker logs --tail 80 "$t" || true
    return 0
  fi

  # 6) Ch·ªù ·ªïn ƒë·ªãnh + set MTU (n·∫øu ƒë·∫∑t)
  sleep 2
  if [[ -n "$TUN_MTU" ]]; then
    docker exec "$t" sh -c "ip link set dev tun0 mtu $TUN_MTU || true" >/dev/null 2>&1 || true
  fi

  # 7) Ki·ªÉm tra IP egress (retry n·∫øu namespace ch∆∞a join ƒë∆∞·ª£c)
  echo "[ROUTE $idx] ‚úÖ S·∫µn s√†ng. IP egress:"
  for try in 1 2 3; do
    if docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me; then
      echo
      break
    else
      st="$(docker inspect -f '{{.State.Status}}' "$t" 2>/dev/null || echo missing)"
      echo "[CHECK] Th·ª≠ $try/3 th·∫•t b·∫°i (status: $st) ‚Üí ƒë·ª£i 2s r·ªìi th·ª≠ l·∫°i..."
      sleep 2
      if [[ "$st" != "running" ]]; then
        echo "[LOG] Dump log g·∫ßn ƒë√¢y:"
        docker logs --tail 80 "$t" || true
      fi
    fi
  done

  echo
  echo "[ROUTE $idx] G·∫Øn container client:"
  echo "  docker run ... --network=container:${t} <image> ..."
}

status_all() {
  local i=1 t
  for _ in "${UPSTREAMS[@]}"; do
    t="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$t"; then
      printf "[STATUS] %s (%s) IP: " \
        "$t" "$(docker inspect -f '{{.State.Status}}' "$t" 2>/dev/null)"
      docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me || true
      echo
    else
      echo "[STATUS] $t: not running"
    fi
    ((i++))
  done
}

down_all() {
  echo "[CLEANUP] Xo√° to√†n b·ªô tuy·∫øn..."
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    cleanup_route "$i"
    ((i++))
  done
  echo "[DONE]"
}

# ===================== CLI =====================
case "${1:-up}" in
  up)
    i=1
    for up in "${UPSTREAMS[@]}"; do
      start_route "$i" "$up"
      ((i++))
      sleep 0.3
    done
    echo
    echo "‚úÖ ƒê√É KH·ªûI T·∫†O (ho·∫∑c b·ªè qua) ${#UPSTREAMS[@]} tuy·∫øn."
    echo "üëâ D√πng: docker run ... --network=container:tunN ..."
    ;;
  status) status_all ;;
  down)   down_all ;;
  *)
    echo "Usage: $0 [up|status|down]"
    exit 1
    ;;
esac
