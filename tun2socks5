#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Danh s√°ch SOCKS5 (d·∫°ng: host:port ho·∫∑c user:pass@host:port)
PROXIES=(
"156.239.204.25:1339"
"156.239.201.49:1339"
"156.239.202.151:1339"
"156.239.201.0:1339"
"156.239.196.11:1339"
"156.239.203.251:1339"
"156.239.205.107:1339"
"156.239.198.52:1339"
"156.239.195.73:1339"
"156.239.197.103:1339"
"156.239.199.213:1339"
"156.239.199.167:1339"
"156.239.215.254:1339"
)

# T√™n base container
SB_NAME_BASE="net-proxy"        # net-proxy1, net-proxy2,...

# Image
IMG_SINGBOX="ghcr.io/sagernet/sing-box:latest"

# DoH server (DNS s·∫Ω ƒëi qua proxy nh·ªù "detour": "proxy")
DOH_ADDR="https://1.1.1.1/dns-query"

# Log level
SB_LOGLEVEL="info"              # debug|info|warn|error

# File xu·∫•t IP
OUT_FILE="route_ips.csv"

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] Docker ch∆∞a c√†i."; exit 1; }

if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] T·∫°o /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

# ===================== FUNCTIONS =====================
cleanup_one() {
  local idx="$1"
  docker rm -f "${SB_NAME_BASE}${idx}" >/dev/null 2>&1 || true
  rm -f "singbox_${idx}.json" || true
}

parse_proxy() {
  # Input: "$1" = "host:port" ho·∫∑c "user:pass@host:port"
  local raw="$1"
  local user="" pass="" hostport="$raw" host="" port=""

  if [[ "$raw" == *"@"* ]]; then
    local creds="${raw%%@*}"; hostport="${raw#*@}"
    user="${creds%%:*}"; pass="${creds#*:}"
  fi
  host="${hostport%%:*}"
  port="${hostport##*:}"

  echo "$user|$pass|$host|$port"
}

gen_singbox_config() {
  local idx="$1"
  local raw="$2"
  local parsed; parsed=$(parse_proxy "$raw")
  local user="${parsed%%|*}"; parsed="${parsed#*|}"
  local pass="${parsed%%|*}"; parsed="${parsed#*|}"
  local host="${parsed%%|*}"; local port="${parsed#*|}"
  local cfg="singbox_${idx}.json"

  # Kh·ªëi outbound socks (th√™m username/password n·∫øu c√≥)
  local OUT_SOCKS
  if [[ -n "$user" || -n "$pass" ]]; then
    OUT_SOCKS=$(cat <<JSON
{ "tag": "proxy", "type": "socks",
  "server": "${host}", "server_port": ${port}, "version": "5",
  "username": "${user}", "password": "${pass}"
}
JSON
)
  else
    OUT_SOCKS=$(cat <<JSON
{ "tag": "proxy", "type": "socks",
  "server": "${host}", "server_port": ${port}, "version": "5"
}
JSON
)
  fi

  cat > "$cfg" <<EOF
{
  "log": { "level": "${SB_LOGLEVEL}" },

  "dns": {
  "strategy": "prefer_ipv4",
  "servers": [
    {
      "tag": "doh",
      "address": "https://1.1.1.1/dns-query",
      "server_name": "cloudflare-dns.com",
      "detour": "proxy"
    },
    { "tag": "local", "address": "local" }
  ]
}
  },

  "inbounds": [
    {
      "type": "tun",
      "inet4_address": "172.19.${idx}.1/30",
      "auto_route": true,
      "strict_route": true,
      "stack": "system",
      "sniff": true,
      "sniff_override_destination": true
    }
  ],

  "outbounds": [
    ${OUT_SOCKS},
    { "tag": "direct", "type": "direct" },
    { "tag": "block", "type": "block" }
  ],

  "route": {
    "rules": [
      { "outbound": "proxy", "network": "tcp,udp" }
    ]
  }
}
EOF
}

start_one() {
  local idx="$1"
  local raw="$2"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $raw"
  cleanup_one "$idx"
  gen_singbox_config "$idx" "$raw"

  local sb="${SB_NAME_BASE}${idx}"
  echo "[ROUTE $idx] Kh·ªüi ch·∫°y sing-box (TUN + DNS qua proxy)..."
  docker run -d --name "$sb" --restart=always \
    --cap-add=NET_ADMIN \
    --device=/dev/net/tun \
    -v "$PWD/singbox_${idx}.json:/etc/sing-box/config.json:ro" \
    "$IMG_SINGBOX" run -c /etc/sing-box/config.json >/dev/null

  # ƒê·ª£i tuy·∫øn s·∫µn s√†ng (t·ªëi ƒëa ~8s)
  for _ in 1 2 3 4; do
    sleep 2
    if docker run --rm --network=container:"$sb" curlimages/curl:latest -s --max-time 6 https://ifconfig.me >/dev/null 2>&1; then
      break
    fi
  done

  # Test & l·∫•y IP
  local ip=""
  ip=$(docker run --rm --network=container:"$sb" \
        curlimages/curl:latest -s --max-time 10 https://ifconfig.me || true)

  if [[ -n "$ip" ]]; then
    echo "[ROUTE $idx] ‚úÖ Ho·∫°t ƒë·ªông. Public IP: $ip"
  else
    echo "[ROUTE $idx] ‚ö†Ô∏è Kh√¥ng l·∫•y ƒë∆∞·ª£c IP (c√≥ th·ªÉ DNS/proxy l·ªói)."
  fi

  # G·ª£i √Ω d√πng tuy·∫øn n√†y cho container kh√°c
  echo "üëâ D√πng tuy·∫øn $idx:"
  echo "   docker run --rm --network=container:${sb} curlimages/curl:latest -s https://ifconfig.me"
}

status_all() {
  local i=1
  for _ in "${PROXIES[@]}"; do
    local sb="${SB_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$sb"; then
      printf "[STATUS] %-12s " "$sb"
      docker run --rm --network=container:"$sb" \
        curlimages/curl:latest -s --max-time 6 https://ifconfig.me || true
      docker ps --format ' - {{.Names}}: {{.Status}}' | grep -E "$sb" || true
    else
      echo "[STATUS] $sb: not running"
    fi
    ((i++))
  done
}

write_ip_table() {
  echo "route,proxy,public_ip" > "$OUT_FILE"
  local i=1
  for p in "${PROXIES[@]}"; do
    local sb="${SB_NAME_BASE}${i}"
    local ip=""
    if docker ps --format '{{.Names}}' | grep -qx "$sb"; then
      ip=$(docker run --rm --network=container:"$sb" \
            curlimages/curl:latest -s --max-time 10 https://ifconfig.me || true)
    fi
    echo "${i},${p},${ip}" >> "$OUT_FILE"
    ((i++))
  done
  echo "[INFO] ƒê√£ ghi b·∫£ng IP ‚Üí $OUT_FILE"
}

down_all() {
  echo "[CLEANUP] Xo√° t·∫•t c·∫£ sing-box container..."
  local i=1
  for _ in "${PROXIES[@]}"; do
    cleanup_one "$i"
    ((i++))
  done
  echo "[DONE]"
}

# ===================== CLI =====================
case "${1:-up}" in
  up)
    i=1
    for p in "${PROXIES[@]}"; do
      start_one "$i" "$p"
      ((i++))
      sleep 0.3
    done
    write_ip_table
    echo
    echo "‚úÖ ƒê√É KH·ªûI T·∫†O ${#PROXIES[@]} TUY·∫æN."
    echo "üëâ Ki·ªÉm tra nhanh: bash $0 status"
    echo "üëâ B·∫£ng IP: $OUT_FILE"
    ;;
  status)
    status_all
    ;;
  list)
    if [[ -f "$OUT_FILE" ]]; then
      echo "=== $OUT_FILE ==="
      column -s, -t "$OUT_FILE" || cat "$OUT_FILE"
    else
      echo "[WARN] Ch∆∞a c√≥ $OUT_FILE ‚Äî h√£y ch·∫°y: bash $0 up"
    fi
    ;;
  down)
    down_all
    ;;
  *)
    echo "Usage: $0 [up|status|list|down]"
    exit 1
    ;;
esac
