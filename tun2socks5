#!/usr/bin/env bash
set -Eeuo pipefail

# ======= C·∫§U H√åNH =======
UPSTREAMS=(
  "socks5://156.239.204.25:1339"
  "socks5://156.239.201.49:1339"
  "socks5://156.239.202.151:1339"
  "socks5://156.239.201.0:1339"
  "socks5://156.239.196.11:1339"
)
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"
TUN_NAME_BASE="tun"
TUN_LOGLEVEL="info"     # debug|info|warn|error
TUN_MTU=""              # v√≠ d·ª• "1400" n·∫øu g·∫∑p timeout

# ======= PRECHECK =======
command -v docker >/dev/null 2>&1 || { echo "[ERR] Ch∆∞a c√†i Docker"; exit 1; }
if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] T·∫°o /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

# ======= H√ÄM PH·ª§ =======
cleanup_one() {
  local idx="$1"
  docker rm -f "${TUN_NAME_BASE}${idx}" >/dev/null 2>&1 || true
  rm -f "resolv_${idx}.conf" || true
}

probe_socks5_tcp() {
  # Test TCP qua proxy (kh√¥ng test DNS). Th√†nh c√¥ng => proxy m·ªü c·ªïng OK.
  local proxy="$1"
  curl -sS -x "$proxy" -I https://www.google.com --max-time 5 >/dev/null
}

start_one() {
  local idx="$1"
  local proxy="$2"
  local name="${TUN_NAME_BASE}${idx}"
  local resolv="resolv_${idx}.conf"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $proxy"

  # Test nhanh proxy (TCP)
  if ! probe_socks5_tcp "$proxy"; then
    echo "[ROUTE $idx] ‚ùå Proxy kh√¥ng ph·∫£n h·ªìi TCP ‚Üí b·ªè qua."
    return 0
  fi

  cleanup_one "$idx"

  # DNS: d√πng DNS b√¨nh th∆∞·ªùng (kh√¥ng DoH, kh√¥ng socks5h). N·∫øu b·∫°n mu·ªën DNS qua proxy,
  # ta c·∫ßn ‚ÄòTCP h√≥a‚Äô DNS ho·∫∑c overlay kh√°c. T·∫°m th·ªùi d√πng 1.1.1.1 ƒë·ªÉ ·ªïn ƒë·ªãnh.
  cat >"$resolv" <<EOF
options ndots:0
nameserver 1.1.1.1
nameserver 1.0.0.1
EOF

  echo "[ROUTE $idx] Kh·ªüi ch·∫°y tun2socks..."
  docker run -d --name "$name" --restart=always \
    --cap-add=NET_ADMIN \
    -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/$resolv":/etc/resolv.conf:ro \
    -e PROXY="$proxy" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="ip rule add iif lo ipproto udp dport 53 lookup main;" \
    "$IMG_TUN" >/dev/null || { echo "[ROUTE $idx] ‚ùå L·ªói kh·ªüi ch·∫°y"; return 0; }

  [[ -n "$TUN_MTU" ]] && docker exec "$name" sh -c "ip link set dev tun0 mtu $TUN_MTU || true" >/dev/null 2>&1 || true

  # Ch·ªù container l√™n r·ªìi check IP egress
  for _ in 1 2 3; do
    st="$(docker inspect -f '{{.State.Status}}' "$name" 2>/dev/null || true)"
    [[ "$st" == "running" ]] && break
    sleep 1
  done

  if [[ "$(docker inspect -f '{{.State.Status}}' "$name" || echo "")" != "running" ]]; then
    echo "[ROUTE $idx] ‚ùå Container kh√¥ng ch·∫°y (status != running). Log:"
    docker logs --tail=50 "$name" || true
    return 0
  fi

  echo "[ROUTE $idx] ‚úÖ S·∫µn s√†ng. IP egress:"
  docker run --rm --network=container:"$name" curlimages/curl:latest -s https://ifconfig.me || true
  echo
  echo "[ROUTE $idx] G·∫Øn container client:"
  echo "  docker run ... --network=container:${name} <image> ..."
}

down_all() {
  echo "[CLEANUP] Xo√° to√†n b·ªô tuy·∫øn..."
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    cleanup_one "$i"
    ((i++))
  done
  echo "[DONE]"
}

status_all() {
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    local n="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$n"; then
      printf "[STATUS] %s IP: " "$n"
      docker run --rm --network=container:"$n" curlimages/curl:latest -s https://ifconfig.me || true
      echo
    else
      echo "[STATUS] $n: not running"
    fi
    ((i++))
  done
}

# ======= CLI =======
case "${1:-up}" in
  up)
    i=1
    for p in "${UPSTREAMS[@]}"; do
      start_one "$i" "$p"
      ((i++))
    done
    echo
    echo "‚úÖ ƒê√É KH·ªûI T·∫†O (ho·∫∑c b·ªè qua) ${#UPSTREAMS[@]} tuy·∫øn."
    echo "üëâ D√πng: docker run ... --network=container:tunN ..."
    ;;
  status) status_all ;;
  down)   down_all ;;
  *) echo "Usage: $0 [up|status|down]"; exit 1 ;;
esac
