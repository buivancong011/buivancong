#!/usr/bin/env bash
set -Eeuo pipefail

# ====== KHAI BÁO PROXY (SOCKS5 có auth) ======
# Định dạng: user:pass@IP:PORT
PROXIES=(
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.204.25:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.201.49:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.202.151:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.201.0:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.196.11:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.203.251:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.205.107:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.198.52:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.195.73:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.197.103:1339"
)

SBOX_IMG="${SBOX_IMG:-ghcr.io/sagernet/sing-box:latest}"   # v1.12+ (schema mới)
NAME_BASE="sbox"                                          # sbox1, sbox2, ...
# Chọn DoT (TLS) để gọn nhẹ. Toàn bộ truy vấn DNS sẽ đi QUA proxy (detour:"proxy")
DNS_SERVERS=("tls://1.1.1.1" "tls://8.8.8.8")
DNS_STRATEGY="ipv4_only"    # tránh v6 nếu hạ tầng không hỗ trợ

require() { command -v "$1" >/dev/null 2>&1 || { echo "Thiếu $1"; exit 1; }; }

make_config() {
  local idx="$1" up="$2" cfg="sbox_${idx}.json"

  local userpass host port
  userpass="${up%@*}"; hostport="${up#*@}"
  host="${hostport%:*}"; port="${hostport#*:}"
  user="${userpass%%:*}"; pass="${userpass#*:}"

  # Mỗi route 1 /30 khác nhau để tránh xung đột
  # 172.30.X.1/30 với X=idx
  local inet4="172.30.${idx}.1/30"

  # JSON schema mới (tun + dns + outbound socks + final proxy)
  cat > "$cfg" <<EOF
{
  "log": { "level": "info" },
  "inbounds": [
    {
      "type": "tun",
      "inet4_address": "${inet4}",
      "auto_route": true,
      "strict_route": true,
      "stack": "system",
      "sniff": false
    }
  ],
  "dns": {
    "servers": [
      { "address": "${DNS_SERVERS[0]}", "detour": "proxy", "strategy": "${DNS_STRATEGY}" },
      { "address": "${DNS_SERVERS[1]}", "detour": "proxy", "strategy": "${DNS_STRATEGY}" }
    ],
    "strategy": "${DNS_STRATEGY}",
    "independent_cache": true
  },
  "outbounds": [
    {
      "type": "socks",
      "tag": "proxy",
      "server": "${host}",
      "server_port": ${port},
      "username": "${user}",
      "password": "${pass}",
      "udp_over_tcp": { "enabled": false }
    },
    { "type": "direct", "tag": "DIRECT" },
    { "type": "block",  "tag": "BLOCK" }
  ],
  "route": {
    "final": "proxy",
    "auto_detect_interface": true
  }
}
EOF
}

start_one() {
  local idx="$1" up="$2"
  local name="${NAME_BASE}${idx}"
  local cfg="sbox_${idx}.json"

  docker rm -f "$name" >/dev/null 2>&1 || true
  make_config "$idx" "$up"

  docker run -d --name "$name" \
    --cap-add=NET_ADMIN --device /dev/net/tun \
    -v "$PWD/${cfg}:/etc/sing-box/config.json:ro" \
    --restart=always "$SBOX_IMG" run -c /etc/sing-box/config.json >/dev/null

  # Test nhanh qua IP (không phụ thuộc DNS)
  echo -n "[ROUTE $idx] "
  docker run --rm --network=container:"$name" curlimages/curl:latest \
    -s -o /dev/null -w "IP ttfb=%{time_starttransfer}s total=%{time_total}s\n" https://1.1.1.1 || echo "test-fail"
}

cmd_up() {
  require docker
  # Đảm bảo /dev/net/tun tồn tại
  [[ -e /dev/net/tun ]] || { mkdir -p /dev/net && mknod /dev/net/tun c 10 200 && chmod 666 /dev/net/tun; }

  local i=1
  for p in "${PROXIES[@]}"; do
    echo "------------------------------------------------------------"
    echo "[ROUTE $i] SOCKS5: ${p}"
    start_one "$i" "$p"
    echo "→ Gắn app vào route này:"
    echo "   - App hỗ trợ SOCKS5H:   curl --socks5-hostname ${p} https://..."
    echo "   - App dạng container:   docker run ... --network=container:${NAME_BASE}${i} <image> ..."
    ((i++))
  done
  echo
  echo "✅ HOÀN TẤT. DNS đang chạy TRONG sing-box và đi QUA proxy (detour:\"proxy\")."
}

cmd_status() {
  docker ps -a --format 'table {{.Names}}\t{{.Status}}' | grep "^${NAME_BASE}" || true
  for i in $(docker ps --format '{{.Names}}' | grep "^${NAME_BASE}" | sed "s/${NAME_BASE}//"); do
    printf "%s  " "${NAME_BASE}${i}"
    docker run --rm --network=container:${NAME_BASE}${i} curlimages/curl -s https://1.1.1.1/cdn-cgi/trace | grep '^ip=' || true
  done
}

cmd_down() {
  docker rm -f $(docker ps -aq -f "name=^${NAME_BASE}") 2>/dev/null || true
  rm -f sbox_*.json || true
  echo "Đã gỡ toàn bộ ${NAME_BASE}*."
}

case "${1:-up}" in
  up)     cmd_up ;;
  status) cmd_status ;;
  down)   cmd_down ;;
  *) echo "Usage: $0 [up|status|down]"; exit 1 ;;
esac
