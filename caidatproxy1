#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Danh sách proxy SOCKS5 có auth (port 1339)
# Format: user:pass@ip:port
PROXIES=(
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.204.25:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.201.49:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.202.151:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.201.0:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.196.11:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.203.251:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.205.107:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.198.52:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.195.73:1339"
"cao_nAEfN2:g2Bawi4kkDZyztX@156.239.197.103:1339"
)

# Image
IMG_SBOX="ghcr.io/sagernet/sing-box:latest"

# Tên container base
NAME_BASE="sbox"

# MTU đề xuất (giảm nếu gặp fragmentation)
TUN_MTU="1400"

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] Cần Docker"; exit 1; }

# Linux cần /dev/net/tun
if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] Tạo /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 666 /dev/net/tun || true
fi

# ===================== FUNCTIONS =====================
mk_cfg() {
  # Tạo config JSON sing-box theo schema mới (KHÔNG DoH).
  # - Inbound: TUN auto-route (UDP/TCP capture)
  # - Outbound: SOCKS5 (sing-box xử lý domain trực tiếp; không cấu hình DNS riêng)
  local idx="$1"
  local userpass_hostport="$2"  # user:pass@host:port

  local userpass="${userpass_hostport%@*}"
  local hostport="${userpass_hostport#*@}"
  local user="${userpass%%:*}"
  local pass="${userpass#*:}"
  local host="${hostport%%:*}"
  local port="${hostport##*:}"

  cat > "sbox_${idx}.json" <<EOF
{
  "log": { "level": "warn" },
  "inbounds": [
    {
      "type": "tun",
      "tag": "in-tun",
      "interface_name": "${NAME_BASE}${idx}",
      "inet4_address": "172.31.${idx}.1/30",
      "mtu": ${TUN_MTU},
      "auto_route": true,
      "strict_route": false,
      "stack": "system",
      "sniff": true
    }
  ],
  "outbounds": [
    {
      "type": "socks",
      "tag": "upstream",
      "server": "${host}",
      "server_port": ${port},
      "version": "5",
      "username": "${user}",
      "password": "${pass}"
    },
    { "type": "direct", "tag": "direct" },
    { "type": "block",  "tag": "block"  }
  ],
  "route": {
    "final": "upstream",
    "auto_detect_interface": true
  }
}
EOF
}

start_one() {
  local idx="$1"
  local up="$2"
  local name="${NAME_BASE}${idx}"

  docker rm -f "$name" >/dev/null 2>&1 || true
  mk_cfg "$idx" "$up"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] SOCKS5: ${up}"
  docker run -d --name "$name" --restart=always \
    --cap-add=NET_ADMIN --device /dev/net/tun \
    -v "$PWD/sbox_${idx}.json":/etc/sing-box/config.json:ro \
    "$IMG_SBOX" run -c /etc/sing-box/config.json >/dev/null

  # === Wait until the container is actually RUNNING and not RESTARTING ===
  # Chờ tối đa ~10s (20 x 0.5s)
  local ok=""
  for _ in {1..20}; do
    # Lấy state + restarting flag
    local st; st="$(docker inspect -f '{{.State.Status}} {{.State.Running}} {{.State.Restarting}}' "$name" 2>/dev/null || true)"
    # Ví dụ: "running true false"
    if [[ "$st" =~ running\ true\ false ]]; then
      ok="yes"
      break
    fi
    sleep 0.5
  done

  if [[ -z "$ok" ]]; then
    echo "[ROUTE $idx] ❌ Container không ổn định (vẫn restarting). Logs:"
    docker logs "$name" || true
    return
  fi

  # Set MTU nếu cần (best-effort)
  if [[ -n "${TUN_MTU}" ]]; then
    docker exec "$name" sh -c "ip link set dev ${NAME_BASE}${idx} mtu ${TUN_MTU} || true" >/dev/null 2>&1 || true
  fi

  # === Đo độ trễ: retry nếu gặp lỗi "cannot join network namespace" ===
  local t=""; local attempt=0
  while :; do
    attempt=$((attempt+1))
    t="$(docker run --rm --network=container:"$name" curlimages/curl -s -o /dev/null \
        -w 'connect=%{time_connect}s ttfb=%{time_starttransfer}s total=%{time_total}s' \
        https://www.cloudflare.com/cdn-cgi/trace 2>&1 || true)"

    # Nếu lỗi do namespace (container restart/đổi PID), đợi rồi thử lại
    if echo "$t" | grep -qi 'cannot join network namespace'; then
      [[ $attempt -lt 10 ]] && { sleep 1; continue; } || true
    fi
    break
  done

  # Nếu curl trả lỗi non-zero, in “FAIL” kèm gợi ý xem log
  if echo "$t" | grep -qiE 'cannot join network|error|FAIL'; then
    echo "[ROUTE $idx] latency: FAIL"
    echo "[ROUTE $idx] Gợi ý: docker logs $name ; docker inspect $name --format '{{json .State}}'"
  else
    echo "[ROUTE $idx] latency: $t"
  fi

  echo "[ROUTE $idx] RUNNING: $name"
  echo "→ App hỗ trợ SOCKS5H:   curl --socks5-hostname USER:PASS@IP:PORT https://..."
  echo "→ App container chia sẻ: docker run ... --network=container:${name} <image> ..."
}


# ===================== CLI =====================
case "${1:-up}" in
  up)
    i=1
    for up in "${PROXIES[@]}"; do
      start_one "$i" "$up"
      ((i++))
    done
    echo
    echo "✅ ĐÃ KHỞI TẠO $((${#PROXIES[@]})) ROUTES (sing-box, KHÔNG DoH)."
    echo "ℹ️  Khuyến nghị: với app CLI, dùng SOCKS5H để DNS resolve tại proxy."
    ;;
  status)
    status_all
    ;;
  down)
    stop_all
    ;;
  test)
    test_all
    ;;
  *)
    echo "Usage: $0 [up|status|down|test]"
    exit 1
    ;;
esac
