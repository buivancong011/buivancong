#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Upstreams c√≥ th·ªÉ l√†: http://user:pass@host:port (HTTP-only)
# (N·∫øu sau n√†y c√≥ SOCKS/SS ch·ªâ vi·ªác thay ti·ªÅn t·ªë th√†nh socks5:// ho·∫∑c ss://)
UPSTREAMS=(
  "http://user34602:1756884666@103.82.25.9:34602"
  "http://user34522:1757060107@103.82.25.9:34522"
)

START_SOCKS=1080
GLIDER_NAME_BASE="glider"
TUN_NAME_BASE="tun"
DOH_NAME_BASE="doh"

IMG_GLIDER="nadoo/glider:latest"
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"
IMG_DOH="cloudflare/cloudflared:latest"

TUN_LOGLEVEL="info"            # debug|info|warn|error
TUN_MTU_DEFAULT="1380"         # MTU th·∫•p gi√∫p TLS/WS ·ªïn ƒë·ªãnh h∆°n
ENABLE_SOCKS_GUARD=1           # 1 = ch·∫∑n truy c·∫≠p c·ªïng SOCKS t·ª´ internet

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] C·∫ßn Docker."; exit 1; }

# /dev/net/tun cho Linux
if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] T·∫°o /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

# L·∫•y gateway host cho container truy c·∫≠p glider (∆∞u ti√™n docker0; fallback default gw)
HOST_GW="$(ip -4 addr show docker0 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1 || true)"
if [[ -z "${HOST_GW}" ]]; then
  HOST_GW="$(ip route show default 2>/dev/null | awk '/default/{print $3}' | head -n1 || true)"
fi
[[ -z "${HOST_GW}" ]] && { echo "[ERR] Kh√¥ng x√°c ƒë·ªãnh ƒë∆∞·ª£c gateway host."; exit 1; }

# ===================== FUNCTIONS =====================
cleanup_route() {
  local idx="$1"
  docker rm -f "${DOH_NAME_BASE}${idx}" "${TUN_NAME_BASE}${idx}" "${GLIDER_NAME_BASE}${idx}" >/dev/null 2>&1 || true
  rm -f "resolv_${idx}.conf" || true
}

sock_guard() {
  local port="$1"
  [[ "$ENABLE_SOCKS_GUARD" -eq 1 ]] || return 0
  # Cho ph√©p t·ª´ d·∫£i docker bridge (172.16.0.0/12), ch·∫∑n c√≤n l·∫°i
  sudo iptables -C INPUT -p tcp --dport "$port" -s 172.16.0.0/12 -j ACCEPT 2>/dev/null || \
  sudo iptables -A INPUT -p tcp --dport "$port" -s 172.16.0.0/12 -j ACCEPT || true
  sudo iptables -C INPUT -p tcp --dport "$port" -j DROP 2>/dev/null || \
  sudo iptables -A INPUT -p tcp --dport "$port" -j DROP || true
}

start_route() {
  local idx="$1"
  local upstream="$2"
  local socks_port=$((START_SOCKS + idx - 1))

  local g="${GLIDER_NAME_BASE}${idx}"
  local t="${TUN_NAME_BASE}${idx}"
  local d="${DOH_NAME_BASE}${idx}"
  local resolv_file="resolv_${idx}.conf"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $upstream"
  echo "[ROUTE $idx] SOCKS5 listen on host: ${socks_port}"

  cleanup_route "$idx"
  docker pull "$IMG_GLIDER" >/dev/null || true
  docker pull "$IMG_TUN"    >/dev/null || true
  docker pull "$IMG_DOH"    >/dev/null || true

  # 1) Glider: HTTP -> SOCKS5 c·ª•c b·ªô
  echo "[ROUTE $idx] Kh·ªüi ch·∫°y glider -> socks5://0.0.0.0:${socks_port}"
  docker run -d --name "$g" --restart=always --network host "$IMG_GLIDER" \
    -verbose \
    -listen "socks5://0.0.0.0:${socks_port}" \
    -forward "$upstream" >/dev/null

  sock_guard "$socks_port" || true

  # 2) resolv.conf trong namespace tun (DNS h·ªèi cloudflared n·ªôi b·ªô)
  cat > "$resolv_file" <<EOF
options ndots:0
nameserver 127.0.0.1
EOF

  # 3) tun2socks: tr·ªè t·ªõi SOCKS5 tr√™n host qua gateway ƒë√£ ph√°t hi·ªán
  echo "[ROUTE $idx] Kh·ªüi ch·∫°y tun2socks (gateway ${HOST_GW})..."
  docker run -d --name "$t" --restart=always \
    --cap-add=NET_ADMIN \
    -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/$resolv_file":/etc/resolv.conf:ro \
    -e PROXY="socks5://${HOST_GW}:${socks_port}" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="ip rule add iif lo ipproto udp dport 53 lookup main;" \
    "$IMG_TUN" >/dev/null

  # 4) Set MTU th·∫•p ƒë·ªÉ tr√°nh fragmentation TLS/WS
  docker exec -it "$t" sh -c "ip link set dev tun0 mtu ${TUN_MTU_DEFAULT} || true" >/dev/null || true

  # 5) Cloudflared DoH trong c√πng namespace v·ªõi tun (DNS nhanh & k√≠n)
  echo "[ROUTE $idx] Kh·ªüi ch·∫°y cloudflared DoH..."
  docker run -d --name "$d" --restart=always \
    --network=container:"$t" \
    --user root \
    "$IMG_DOH" \
    proxy-dns --no-autoupdate \
      --address 127.0.0.1 --port 53 \
      --upstream https://1.1.1.1/dns-query \
      --upstream https://9.9.9.9/dns-query \
      --bootstrap 1.1.1.1,9.9.9.9 >/dev/null

  # 6) Ki·ªÉm tra IP egress nhanh
  echo "[ROUTE $idx] Ki·ªÉm tra IP egress:"
  docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me || true
  echo
  echo "‚áí G·∫Øn container client v√†o tuy·∫øn n√†y b·∫±ng:"
  echo "   docker run ... --network=container:${t} --dns=127.0.0.1 <image> ..."
}

down_all() {
  echo "[CLEANUP] Xo√° to√†n b·ªô tuy·∫øn..."
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    cleanup_route "$i"
    ((i++))
  done
  echo "[DONE] ƒê√£ xo√°."
}

status_all() {
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    local t="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$t"; then
      printf "[STATUS] %s " "$t"
      docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me || true
    else
      echo "[STATUS] $t: not running"
    fi
    ((i++))
  done
}

# ===================== CLI =====================
case "${1:-up}" in
  up)
    i=1
    for up in "${UPSTREAMS[@]}"; do
      start_route "$i" "$up"
      ((i++))
    done
    echo
    echo "‚úÖ ƒê√É KH·ªûI T·∫†O ${#UPSTREAMS[@]} TUY·∫æN."
    echo "üëâ G·∫Øn client v√†o tuy·∫øn N:  --network=container:tunN --dns=127.0.0.1"
    ;;
  status) status_all ;;
  down)   down_all ;;
  *)      echo "Usage: $0 [up|status|down]"; exit 1 ;;
esac
