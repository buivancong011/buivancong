#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
UPSTREAMS=(
  "http://user34602:1756884666@103.82.25.9:34602"
  "http://user34522:1757060107@103.82.25.9:34522"
)

START_SOCKS=1080
GLIDER_NAME_BASE="glider"
TUN_NAME_BASE="tun"

IMG_GLIDER="nadoo/glider:latest"
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"

# Mặc định log thấp để giảm overhead
TUN_LOGLEVEL="error"

# DNS candidates sẽ được đo RTT và chọn nhanh nhất per-route
DNS_CANDIDATES=("1.1.1.1" "8.8.8.8" "9.9.9.9" "1.0.0.1" "8.8.4.4")

# Giới hạn file handles cao để tránh choke
NOFILE=131072

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] Cần Docker."; exit 1; }

if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] Tạo /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

get_bridge_ip() {
  local gw
  gw="$(docker network inspect bridge 2>/dev/null | awk -F'"' '/"Gateway":/ {print $4; exit}')"
  [[ -n "${gw:-}" ]] && echo "$gw" || echo "172.17.0.1"
}

# Ping một IP N lần, trả về RTT trung bình (ms) hoặc 9999 nếu fail
avg_rtt_ms() {
  local ip="$1" count="${2:-3}"
  # -q quiet, -n numeric, -W 1 timeout 1s, -i 0.2 interval
  local out
  if out=$(ping -q -n -c "$count" -W 1 -i 0.2 "$ip" 2>/dev/null | awk -F'/' '/^rtt|round-trip/ {print $5}'); then
    [[ -n "$out" ]] && echo "$out" || echo "9999"
  else
    echo "9999"
  fi
}

# Chọn DNS nhanh nhất theo RTT
pick_fastest_dns() {
  local best_ip="" best_rtt=9999 r
  for ip in "${DNS_CANDIDATES[@]}"; do
    r="$(avg_rtt_ms "$ip" 3)"
    # echo "[DBG] DNS $ip RTT ${r}ms" >&2
    awk 'BEGIN {exit !(ARGC==3 && ARGV[1]+0 < ARGV[2]+0)}' "$r" "$best_rtt" && { best_rtt="$r"; best_ip="$ip"; }
  done
  [[ -n "$best_ip" ]] && echo "$best_ip" || echo "1.1.1.1"
}

# Tìm MTU tối ưu (PMTU probe), trả về số MTU cho tun0 (nếu fail -> 1400)
# Ý tưởng: binary search payload size với DF, sau đó +28 (IP+ICMP) để ra MTU của path,
# và trừ một biên độ nhỏ cho an toàn.
detect_mtu() {
  local host="8.8.8.8" lo=1200 hi=1472 mid ok=1200
  while (( lo <= hi )); do
    mid=$(( (lo+hi)/2 ))
    if ping -M do -s "$mid" -c 1 -W 1 "$host" >/dev/null 2>&1; then
      ok="$mid"; lo=$(( mid+1 ))
    else
      hi=$(( mid-1 ))
    fi
  done
  # payload ok + 28 = MTU IP; giảm 8 để an toàn (VPN/encap khác)
  local mtu=$(( ok + 28 - 8 ))
  (( mtu < 1280 )) && mtu=1280
  echo "$mtu"
}

# ===================== FUNCTIONS =====================
cleanup_route() {
  local idx="$1"
  local g="${GLIDER_NAME_BASE}${idx}"
  local t="${TUN_NAME_BASE}${idx}"
  docker rm -f "$t" "$g" >/dev/null 2>&1 || true
  rm -f "resolv_${idx}.conf" >/dev/null 2>&1 || true
}

start_route() {
  local idx="$1" upstream="$2"
  local socks_port=$((START_SOCKS + idx - 1))
  local g="${GLIDER_NAME_BASE}${idx}"
  local t="${TUN_NAME_BASE}${idx}"
  local resolv_file="resolv_${idx}.conf"
  local bridge_ip; bridge_ip="$(get_bridge_ip)"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $upstream"
  echo "[ROUTE $idx] SOCKS5 on host: ${socks_port} (bridge ${bridge_ip})"

  cleanup_route "$idx"

  # 1) Chọn DNS nhanh nhất cho tuyến này
  local fast_dns; fast_dns="$(pick_fastest_dns)"
  {
    echo "options ndots:0"
    echo "nameserver $fast_dns"
  } > "$resolv_file"
  echo "[ROUTE $idx] DNS nhanh nhất: $fast_dns"

  # 2) PMTU detect và set MTU
  local mtu; mtu="$(detect_mtu)"
  echo "[ROUTE $idx] MTU tối ưu dự kiến: $mtu"

  # 3) Glider -> SOCKS5 (disable verbose để giảm CPU/IO)
  docker run -d --name "$g" --restart=always --network host \
    --ulimit nofile="$NOFILE":"$NOFILE" \
    "$IMG_GLIDER" \
    -listen "socks5://0.0.0.0:${socks_port}" \
    -forward "$upstream" \
    -checkurl "http://connectivitycheck.gstatic.com/generate_204" \
    -checkinterval 10s || { echo "[ERR] glider $g fail"; return 1; }

  # 4) tun2socks (namespace chính cho app) + sysctl tối ưu trong ns
  docker run -d --name "$t" --restart=always \
    --cap-add=NET_ADMIN \
    -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/$resolv_file":/etc/resolv.conf:ro \
    --sysctl net.ipv4.tcp_fastopen=3 \
    --sysctl net.ipv4.tcp_fin_timeout=15 \
    --sysctl net.ipv4.tcp_slow_start_after_idle=0 \
    --sysctl net.core.default_qdisc=fq \
    --sysctl net.ipv4.tcp_congestion_control=bbr \
    --ulimit nofile="$NOFILE":"$NOFILE" \
    -e PROXY="socks5://${bridge_ip}:${socks_port}" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="ip rule add iif lo ipproto udp dport 53 lookup main 2>/dev/null || true; \
                       ip rule add ipproto udp dport 53 lookup main 2>/dev/null || true; \
                       ip link set dev tun0 mtu ${mtu} 2>/dev/null || true" \
    "$IMG_TUN" || { echo "[ERR] tun2socks $t fail"; docker logs "$g" || true; return 1; }

  # 5) Kiểm tra egress IP (nhanh, không kéo dài)
  echo -n "[ROUTE $idx] Egress IP: "
  docker run --rm --network=container:"$t" curlimages/curl:latest -s --max-time 3 https://ifconfig.me || true
  echo
  echo "[ROUTE $idx] READY. Gắn app bằng:  --network=container:${t}"
}

down_all() {
  echo "[CLEANUP] Xoá toàn bộ tuyến..."
  local i=1
  for _ in "${UPSTREAMS[@]}"; do cleanup_route "$i"; ((i++)); done
  echo "[DONE]"
}

status_all() {
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    local t="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$t"; then
      printf "[STATUS] %-12s " "$t"
      docker run --rm --network=container:"$t" curlimages/curl:latest -s --max-time 3 https://ifconfig.me || echo "n/a"
    else
      echo "[STATUS] $t: not running"
    fi
    ((i++))
  done
}

case "${1:-up}" in
  up)
    i=1
    for up in "${UPSTREAMS[@]}"; do start_route "$i" "$up"; ((i++)); done
    echo; echo "✅ ĐÃ KHỞI TẠO ${#UPSTREAMS[@]} TUYẾN. Dùng: --network=container:tunN"
    ;;
  status) status_all ;;
  down)   down_all ;;
  *) echo "Usage: $0 [up|status|down]"; exit 1 ;;
esac
