#!/bin/bash
set -Eeuo pipefail

# ================== CONFIG (HTTP-only, rotating IP support) ==================
# Khuyến nghị: dùng HOSTNAME của proxy provider (không dùng IP cứng) để DNS tự theo IP mới.
UPSTREAMS=(
  "http://user34602:1756884666@103.82.25.9:34602"
  "http://user34522:1757060107@103.82.25.9:34522"
  # ví dụ tốt hơn (nếu provider có): "http://user:pass@rotating.example.com:port"
)

START_SOCKS=1080
GLIDER_NAME_BASE="glider"
TUN_NAME_BASE="tun"
DOH_NAME_BASE="doh"

IMG_GLIDER="nadoo/glider:latest"
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"
IMG_DOH="cloudflare/cloudflared:latest"

# MTU thấp giúp TLS/WebSocket ổn định qua tunnel
TUN_MTUS=(1380 1380)   # có thể đặt khác nhau cho từng tuyến
TUN_LOGLEVEL="info"

# Health-check: 1 đích “nhạy” TLS/WebSocket (EarnFM) + 1 đích phổ thông (Google)
HEALTH1_URL="https://socket.earn.fm:8443/"
HEALTH2_URL="https://google.com"
HEALTH_TIMEOUT="7"
HEALTH_FAIL_RESTART=1   # 1 = nếu health fail -> restart tuyến

# Watch mode: kiểm tra định kỳ (giúp glider re-resolve khi proxy đổi IP)
WATCH_INTERVAL=60       # giây (set 0 để tắt watch)
WATCH_MAX_RESTARTS=3    # số lần restart tối đa trong 1 vòng kiểm

# Bảo vệ cổng SOCKS của glider khỏi Internet
ENABLE_SOCKS_GUARD=1

# ================== PRECHECK ==================
command -v docker >/dev/null || { echo "[ERR] Cần Docker"; exit 1; }

# /dev/net/tun cho Linux
if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] Tạo /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

# Lấy gateway cho container truy cập glider (ưu tiên docker0)
HOST_GW="$(ip -4 addr show docker0 2>/dev/null | awk '/inet /{print $2}' | cut -d/ -f1)"
[[ -z "$HOST_GW" ]] && HOST_GW="$(ip route show default | awk '/default/{print $3}' | head -n1)"
[[ -z "$HOST_GW" ]] && { echo "[ERR] Không xác định gateway host"; exit 1; }

# ================== FUNCS ==================
cleanup_route() {
  local i="$1"
  docker rm -f "${DOH_NAME_BASE}${i}" "${TUN_NAME_BASE}${i}" "${GLIDER_NAME_BASE}${i}" >/dev/null 2>&1 || true
  rm -f "resolv_${i}.conf" || true
}

sock_guard() {
  local port="$1"
  [[ "$ENABLE_SOCKS_GUARD" -eq 1 ]] || return 0
  # Cho phép từ docker subnets, chặn còn lại
  sudo iptables -C INPUT -p tcp --dport "$port" -s 172.16.0.0/12 -j ACCEPT 2>/dev/null || \
  sudo iptables -A INPUT -p tcp --dport "$port" -s 172.16.0.0/12 -j ACCEPT || true
  sudo iptables -C INPUT -p tcp --dport "$port" -j DROP 2>/dev/null || \
  sudo iptables -A INPUT -p tcp --dport "$port" -j DROP || true
}

start_route() {
  local i="$1"; local upstream="$2"; local port=$((START_SOCKS + i - 1))
  local g="${GLIDER_NAME_BASE}${i}"; local t="${TUN_NAME_BASE}${i}"; local d="${DOH_NAME_BASE}${i}"
  local mtu="${TUN_MTUS[$((i-1))]:-1380}"

  echo "---------------- [ROUTE $i] ----------------"
  echo "[UPSTREAM] $upstream"
  cleanup_route "$i"

  docker pull "$IMG_GLIDER" >/dev/null || true
  docker pull "$IMG_TUN"    >/dev/null || true
  docker pull "$IMG_DOH"    >/dev/null || true

  echo "[GLIDER] socks5://0.0.0.0:${port} -> $upstream"
  docker run -d --name "$g" --restart=always --network host "$IMG_GLIDER" \
    -verbose -listen "socks5://0.0.0.0:${port}" -forward "$upstream" >/dev/null

  sock_guard "$port"

  cat > "resolv_${i}.conf" <<EOF
options ndots:0
nameserver 127.0.0.1
EOF

  echo "[TUN2SOCKS] proxy socks5://${HOST_GW}:${port} (MTU=$mtu)"
  docker run -d --name "$t" --restart=always \
    --cap-add=NET_ADMIN -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/resolv_${i}.conf":/etc/resolv.conf:ro \
    -e PROXY="socks5://${HOST_GW}:${port}" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="ip rule add iif lo ipproto udp dport 53 lookup main;" \
    "$IMG_TUN" >/dev/null

  docker exec -it "$t" sh -c "ip link set dev tun0 mtu ${mtu} || true" >/dev/null || true

  echo "[DoH] cloudflared"
  docker run -d --name "$d" --restart=always \
    --network=container:"$t" --user root "$IMG_DOH" \
    proxy-dns --no-autoupdate \
      --address 127.0.0.1 --port 53 \
      --upstream https://1.1.1.1/dns-query \
      --upstream https://9.9.9.9/dns-query \
      --bootstrap 1.1.1.1,9.9.9.9 >/dev/null

  echo "[Egress IP]"
  docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me || true
  echo

  health_route "$i" || {
    echo "[WARN] Health fail ngay sau khi dựng tuyến $i."
    [[ "$HEALTH_FAIL_RESTART" -eq 1 ]] && restart_route "$i"
  }

  echo "⇒ Gắn client:  --network=container:${t} (kèm --dns=127.0.0.1)"
}

health_route() {
  local i="$1"; local t="${TUN_NAME_BASE}${i}"
  echo "[HEALTH-$i] $HEALTH1_URL"
  docker run --rm --network=container:"$t" curlimages/curl:latest -s \
    -w '\nDNS:%{time_namelookup}s TLS:%{time_appconnect}s TTFB:%{time_starttransfer}s TOTAL:%{time_total}s\n' \
    --max-time "$HEALTH_TIMEOUT" "$HEALTH1_URL" -o /dev/null || return 1

  echo "[HEALTH-$i] $HEALTH2_URL"
  docker run --rm --network=container:"$t" curlimages/curl:latest -s \
    -w '\nTLS:%{time_appconnect}s TOTAL:%{time_total}s\n' \
    --max-time "$HEALTH_TIMEOUT" "$HEALTH2_URL" -o /dev/null || return 1
}

restart_route() {
  local i="$1"
  echo "[RESTART] Tuyến $i (glider + tun + doh)"
  local g="${GLIDER_NAME_BASE}${i}"; local t="${TUN_NAME_BASE}${i}"; local d="${DOH_NAME_BASE}${i}"
  docker restart "$g" >/dev/null || true
  docker restart "$t" >/dev/null || true
  docker restart "$d" >/dev/null || true
}

status_all() {
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    local t="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$t"; then
      printf "[STATUS] %s " "$t"
      docker run --rm --network=container:"$t" curlimages/curl:latest -s https://ifconfig.me || true
    else
      echo "[STATUS] $t: not running"
    fi
    ((i++))
  done
}

watch_loop() {
  [[ "$WATCH_INTERVAL" -gt 0 ]] || { echo "[WATCH] Tắt (WATCH_INTERVAL=0)"; return 0; }
  echo "[WATCH] Bật, interval=${WATCH_INTERVAL}s"
  while true; do
    local i=1
    for _ in "${UPSTREAMS[@]}"; do
      if ! health_route "$i" >/dev/null 2>&1; then
        echo "[WATCH] Health fail tuyến $i → thử restart"
        local tries=0
        while ! health_route "$i" >/dev/null 2>&1; do
          ((tries++)); [[ $tries -gt $WATCH_MAX_RESTARTS ]] && break
          restart_route "$i"
          sleep 3
        done
      fi
      ((i++))
    done
    sleep "$WATCH_INTERVAL"
  done
}

# ================== CLI ==================
case "${1:-up}" in
  up)
    i=1; for up in "${UPSTREAMS[@]}"; do start_route "$i" "$up"; ((i++)); done
    echo; echo "✅ KHỞI TẠO XONG ${#UPSTREAMS[@]} TUYẾN."
    echo "👉 Gắn client:  docker run ... --network=container:tunN --dns=127.0.0.1 ..."
    ;;
  status) status_all ;;
  down)   i=1; for _ in "${UPSTREAMS[@]}"; do cleanup_route "$i"; ((i++)); done; echo "[DONE]" ;;
  watch)  watch_loop ;;
  *)      echo "Usage: $0 [up|status|down|watch]"; exit 1 ;;
esac
