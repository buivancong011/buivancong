#!/bin/bash
set -Eeuo pipefail

# ===================== CONFIG =====================
# Khai báo upstream proxy dạng URI (có thể trộn nhiều loại):
#  - HTTP(S):   http://user:pass@host:port
#  - SOCKS5:    socks5://user:pass@host:port
#  - Shadowsocks/VMess/Trojan/VLESS: theo cú pháp glider -forward
UPSTREAMS=(
  "http://user34602:1756884666@103.82.25.9:34602"
  "http://user34522:1757060107@103.82.25.9:34522"
)

# Cổng SOCKS5 lắng nghe trên host cho từng tuyến (tuyến i dùng START_SOCKS+i-1)
START_SOCKS=1080

# Tên base cho container theo tuyến
GLIDER_NAME_BASE="glider"
TUN_NAME_BASE="tun"

# Image
IMG_GLIDER="nadoo/glider:latest"
IMG_TUN="xjasonlyu/tun2socks:v2.6.0"

# Log level cho tun2socks: debug|info|warn|error
TUN_LOGLEVEL="error"

# DNS candidates sẽ được đo RTT và chọn nhanh nhất per-route
DNS_CANDIDATES=("1.1.1.1" "8.8.8.8" "9.9.9.9" "1.0.0.1" "8.8.4.4")

# Giới hạn file handles cho glider/tun
NOFILE=131072

# ===================== PRECHECK =====================
command -v docker >/dev/null 2>&1 || { echo "[ERR] Cần Docker."; exit 1; }

if [[ ! -e /dev/net/tun ]]; then
  echo "[INFO] Tạo /dev/net/tun..."
  sudo mkdir -p /dev/net || true
  sudo mknod /dev/net/tun c 10 200 || true
  sudo chmod 600 /dev/net/tun || true
fi

get_bridge_ip() {
  local gw
  gw="$(docker network inspect bridge 2>/dev/null | awk -F'"' '/"Gateway":/ {print $4; exit}')"
  [[ -n "${gw:-}" ]] && echo "$gw" || echo "172.17.0.1"
}

# Ping một IP N lần, trả về RTT trung bình (ms) hoặc 9999 nếu fail
avg_rtt_ms() {
  local ip="$1" count="${2:-3}"
  local out
  if out=$(ping -q -n -c "$count" -W 1 -i 0.2 "$ip" 2>/dev/null | awk -F'/' '/^rtt|round-trip/ {print $5}'); then
    [[ -n "$out" ]] && echo "$out" || echo "9999"
  else
    echo "9999"
  fi
}

# Chọn DNS nhanh nhất theo RTT
pick_fastest_dns() {
  local best_ip="" best_rtt=9999 r
  for ip in "${DNS_CANDIDATES[@]}"; do
    r="$(avg_rtt_ms "$ip" 3)"
    awk 'BEGIN {exit !(ARGC==3 && ARGV[1]+0 < ARGV[2]+0)}' "$r" "$best_rtt" && { best_rtt="$r"; best_ip="$ip"; }
  done
  [[ -n "$best_ip" ]] && echo "$best_ip" || echo "1.1.1.1"
}

# Tìm MTU tối ưu (PMTU probe), trả về MTU cho tun0 (nếu fail -> 1400)
detect_mtu() {
  local host="8.8.8.8" lo=1200 hi=1472 mid ok=1200
  while (( lo <= hi )); do
    mid=$(( (lo+hi)/2 ))
    if ping -M do -s "$mid" -c 1 -W 1 "$host" >/dev/null 2>&1; then
      ok="$mid"; lo=$(( mid+1 ))
    else
      hi=$(( mid-1 ))
    fi
  done
  local mtu=$(( ok + 28 - 8 ))
  (( mtu < 1280 )) && mtu=1280
  echo "$mtu"
}

# ===================== FUNCTIONS =====================
cleanup_route() {
  local idx="$1"
  local g="${GLIDER_NAME_BASE}${idx}"
  local t="${TUN_NAME_BASE}${idx}"
  docker rm -f "$t" "$g" >/dev/null 2>&1 || true
  rm -f "resolv_${idx}.conf" >/dev/null 2>&1 || true
}

start_route() {
  local idx="$1" upstream="$2"
  local socks_port=$((START_SOCKS + idx - 1))
  local g="${GLIDER_NAME_BASE}${idx}"
  local t="${TUN_NAME_BASE}${idx}"
  local resolv_file="resolv_${idx}.conf"
  local bridge_ip; bridge_ip="$(get_bridge_ip)"

  echo "------------------------------------------------------------"
  echo "[ROUTE $idx] Upstream: $upstream"
  echo "[ROUTE $idx] SOCKS5 on host: ${socks_port} (bridge ${bridge_ip})"

  cleanup_route "$idx"

  # 1) DNS nhanh nhất cho tuyến này
  local fast_dns; fast_dns="$(pick_fastest_dns)"
  { echo "options ndots:0"; echo "nameserver $fast_dns"; } > "$resolv_file"
  echo "[ROUTE $idx] DNS nhanh nhất: $fast_dns"

  # 2) PMTU detect và set MTU
  local mtu; mtu="$(detect_mtu)"
  echo "[ROUTE $idx] MTU tối ưu dự kiến: $mtu"

  # 3) Glider -> SOCKS5 (dùng -check hợp lệ, KHÔNG dùng -checkurl)
  docker run -d --name "$g" --restart=always --network host \
    --ulimit nofile="$NOFILE":"$NOFILE" \
    "$IMG_GLIDER" \
    -listen "socks5://0.0.0.0:${socks_port}" \
    -forward "$upstream" \
    -check "http://connectivitycheck.gstatic.com/generate_204#expect=204" \
    -checkinterval 10 || { echo "[ERR] glider $g fail"; return 1; }

  # 4) tun2socks (BỎ mọi --sysctl để tránh lỗi /proc/sys/... không tồn tại)
  docker run -d --name "$t" --restart=always \
    --cap-add=NET_ADMIN \
    -v /dev/net/tun:/dev/net/tun \
    -v "$PWD/$resolv_file":/etc/resolv.conf:ro \
    --ulimit nofile="$NOFILE":"$NOFILE" \
    -e PROXY="socks5://${bridge_ip}:${socks_port}" \
    -e LOGLEVEL="$TUN_LOGLEVEL" \
    -e EXTRA_COMMANDS="ip rule add iif lo ipproto udp dport 53 lookup main 2>/dev/null || true; \
                       ip rule add ipproto udp dport 53 lookup main 2>/dev/null || true; \
                       ip link set dev tun0 mtu ${mtu} 2>/dev/null || true" \
    "$IMG_TUN" || { echo "[ERR] tun2socks $t fail"; docker logs "$g" || true; return 1; }

  # 5) Kiểm tra egress IP
  echo -n "[ROUTE $idx] Egress IP: "
  docker run --rm --network=container:"$t" curlimages/curl:latest -s --max-time 3 https://ifconfig.me || true
  echo
  echo "[ROUTE $idx] READY. Gắn app bằng:  docker run ... --network=container:${t} <image> ..."
}

down_all() {
  echo "[CLEANUP] Xoá toàn bộ tuyến..."
  local i=1
  for _ in "${UPSTREAMS[@]}"; do cleanup_route "$i"; ((i++)); done
  echo "[DONE]"
}

status_all() {
  local i=1
  for _ in "${UPSTREAMS[@]}"; do
    local t="${TUN_NAME_BASE}${i}"
    if docker ps --format '{{.Names}}' | grep -qx "$t"; then
      printf "[STATUS] %-12s " "$t"
      docker run --rm --network=container:"$t" curlimages/curl:latest -s --max-time 3 https://ifconfig.me || echo "n/a"
    else
      echo "[STATUS] $t: not running"
    fi
    ((i++))
  done
}

# ===================== CLI =====================
# ./script.sh           -> khởi chạy tất cả tuyến
# ./script.sh status    -> in IP từng tuyến
# ./script.sh down      -> xoá toàn bộ tuyến
case "${1:-up}" in
  up)
    i=1
    for up in "${UPSTREAMS[@]}"; do start_route "$i" "$up"; ((i++)); done
    echo; echo "✅ ĐÃ KHỞI TẠO ${#UPSTREAMS[@]} TUYẾN. Dùng: --network=container:tunN"
    ;;
  status) status_all ;;
  down)   down_all ;;
  *) echo "Usage: $0 [up|status|down]"; exit 1 ;;
esac
