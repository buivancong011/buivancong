#!/bin/bash
set -euo pipefail

LOCK_FILE="/tmp/setup.lock"
if [ -f "$LOCK_FILE" ]; then
  echo "[WARN] Script đã chạy hoặc reboot chưa xong, dừng lại."
  exit 0
fi
trap "rm -f $LOCK_FILE" EXIT
touch $LOCK_FILE

# ====== Tiện ích cần thiết ======
sudo yum -y install iproute iptables iptables-services curl cronie >/dev/null 2>&1 || true

# ====== Gỡ các gói không mong muốn ======
timeout 60 sudo yum remove -y squid httpd-tools || true

# ====== Docker ======
if ! command -v docker &>/dev/null; then
  echo "[INFO] Cài Docker..."
  timeout 300 sudo yum update -y || true
  timeout 300 sudo yum install -y docker
  sudo systemctl enable docker
  sudo systemctl start docker
  echo "[INFO] Docker cài xong, reboot lần đầu..."
  sleep 5
  sudo reboot
fi

# ====== Cronie ======
if ! command -v crond &>/dev/null; then
  echo "[INFO] Cài Cronie..."
  timeout 120 sudo yum install -y cronie
  sudo systemctl enable --now crond
fi

# ====== Xác định NICs + IP nội bộ / IP công khai ======
ETH_A="eth0"
ETH_B="eth1"
ip link show "$ETH_A" >/dev/null 2>&1 || { echo "[ERROR] Không thấy $ETH_A"; exit 1; }
ip link show "$ETH_B" >/dev/null 2>&1 || { echo "[ERROR] Không thấy $ETH_B"; exit 1; }

IP_A_INT=$(ip -4 addr show dev "$ETH_A" | awk '/inet /{print $2}' | cut -d/ -f1 | head -n1 || true)
IP_B_INT=$(ip -4 addr show dev "$ETH_B" | awk '/inet /{print $2}' | cut -d/ -f1 | head -n1 || true)
[ -n "${IP_A_INT:-}" ] && [ -n "${IP_B_INT:-}" ] || { echo "[ERROR] Không lấy được IP nội bộ cho $ETH_A/$ETH_B"; exit 1; }
echo "[INFO] Nội bộ: $ETH_A=$IP_A_INT ; $ETH_B=$IP_B_INT"

get_ext_ip() {
  local idx="$1"
  curl -s -H "Metadata-Flavor: Google" \
    "http://metadata.google.internal/computeMetadata/v1/instance/network-interfaces/${idx}/access-configs/0/external-ip" || true
}
IP_A_EXT=$(get_ext_ip 0)
IP_B_EXT=$(get_ext_ip 1)
[ -n "$IP_A_EXT" ] && [ -n "$IP_B_EXT" ] || {
  echo "[ERROR] Thiếu EIP: eth0='${IP_A_EXT:-none}', eth1='${IP_B_EXT:-none}'. Hãy gắn EIP cho cả 2 NIC rồi chạy lại."
  exit 1
}
echo "[INFO] Công khai: eth0=$IP_A_EXT ; eth1=$IP_B_EXT"

# ====== Bật IP forwarding và cho phép FORWARD ======
echo "[INFO] Bật IP forwarding & FORWARD chain..."
sudo bash -c 'echo "net.ipv4.ip_forward = 1" > /etc/sysctl.d/99-ipforward.conf'
sudo sysctl -p /etc/sysctl.d/99-ipforward.conf >/dev/null

# (nới lỏng FORWARD tối thiểu để Docker LAN đi ra ngoài qua eth0/eth1)
sudo iptables -P FORWARD ACCEPT 2>/dev/null || true
sudo iptables -C FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || \
  sudo iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
# Cho phép từ các mạng docker tự tạo đi ra hai NIC
for SUB in 192.168.33.0/24 192.168.34.0/24; do
  sudo iptables -C FORWARD -s "$SUB" -o "$ETH_A" -j ACCEPT 2>/dev/null || \
    sudo iptables -I FORWARD -s "$SUB" -o "$ETH_A" -j ACCEPT
  sudo iptables -C FORWARD -s "$SUB" -o "$ETH_B" -j ACCEPT 2>/dev/null || \
    sudo iptables -I FORWARD -s "$SUB" -o "$ETH_B" -j ACCEPT
done

# ====== Xóa containers/images/networks cũ ======
if [ "$(docker ps -q | wc -l)" -gt 0 ]; then
  echo "[WARN] Xóa containers cũ..."
  timeout 60 docker rm -f $(docker ps -aq) || true
fi
if [ "$(docker images -q | wc -l)" -gt 0 ]; then
  echo "[WARN] Xóa images cũ..."
  docker rmi -f $(docker images -q) || true
fi

echo "[INFO] Xóa docker networks cũ..."
for net in $(docker network ls --format '{{.Name}}' | grep -vE '^(bridge|host|none)$'); do
  timeout 30 docker network rm "$net" || true
done

# ====== Tạo lại docker networks ======
docker network create my_network_1 --driver bridge --subnet 192.168.33.0/24 || true
docker network create my_network_2 --driver bridge --subnet 192.168.34.0/24 || true

# ====== NAT theo interface (đảm bảo 2 mạng Docker đều ra Internet) ======
fix_iptables() {
  echo "[INFO] Thiết lập MASQUERADE theo interface..."
  # Xóa rule cũ
  sudo iptables -t nat -D POSTROUTING -s 192.168.33.0/24 -o "$ETH_A" -j MASQUERADE 2>/dev/null || true
  sudo iptables -t nat -D POSTROUTING -s 192.168.34.0/24 -o "$ETH_B" -j MASQUERADE 2>/dev/null || true
  # Thêm rule mới
  sudo iptables -t nat -I POSTROUTING -s 192.168.33.0/24 -o "$ETH_A" -j MASQUERADE
  sudo iptables -t nat -I POSTROUTING -s 192.168.34.0/24 -o "$ETH_B" -j MASQUERADE

  # Lưu & bật iptables service để giữ qua reboot
  if command -v service >/dev/null 2>&1; then
    sudo service iptables save >/dev/null 2>&1 || true
    sudo systemctl enable iptables >/dev/null 2>&1 || true
    sudo systemctl start iptables >/dev/null 2>&1 || true
  fi
}
fix_iptables

# Kiểm tra rule đã áp dụng
sudo iptables -t nat -S POSTROUTING | grep -qE '--source 192\.168\.33\.0/24 .* -o '"$ETH_A"'.* MASQUERADE' || {
  echo "[ERROR] MASQUERADE 192.168.33.0/24 -> $ETH_A chưa áp dụng. Stop Docker."
  sudo systemctl stop docker; exit 1; }
sudo iptables -t nat -S POSTROUTING | grep -qE '--source 192\.168\.34\.0/24 .* -o '"$ETH_B"'.* MASQUERADE' || {
  echo "[ERROR] MASQUERADE 192.168.34.0/24 -> $ETH_B chưa áp dụng. Stop Docker."
  sudo systemctl stop docker; exit 1; }

# ====== Persist NAT/forwarding qua reboot ======
NAT_SCRIPT="/usr/local/sbin/restore_dualnic_nat.sh"
sudo bash -c "cat > $NAT_SCRIPT" <<'EOF'
#!/bin/bash
set -e
# Bật ip_forward
sysctl -w net.ipv4.ip_forward=1 >/dev/null

ETH_A="eth0"
ETH_B="eth1"

# Cho phép FORWARD cơ bản
iptables -P FORWARD ACCEPT 2>/dev/null || true
iptables -C FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT 2>/dev/null || \
  iptables -I FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
for SUB in 192.168.33.0/24 192.168.34.0/24; do
  iptables -C FORWARD -s "$SUB" -o "$ETH_A" -j ACCEPT 2>/dev/null || iptables -I FORWARD -s "$SUB" -o "$ETH_A" -j ACCEPT
  iptables -C FORWARD -s "$SUB" -o "$ETH_B" -j ACCEPT 2>/dev/null || iptables -I FORWARD -s "$SUB" -o "$ETH_B" -j ACCEPT
done

# MASQUERADE theo interface
iptables -t nat -C POSTROUTING -s 192.168.33.0/24 -o "$ETH_A" -j MASQUERADE 2>/dev/null || \
  iptables -t nat -I POSTROUTING -s 192.168.33.0/24 -o "$ETH_A" -j MASQUERADE
iptables -t nat -C POSTROUTING -s 192.168.34.0/24 -o "$ETH_B" -j MASQUERADE 2>/dev/null || \
  iptables -t nat -I POSTROUTING -s 192.168.34.0/24 -o "$ETH_B" -j MASQUERADE
exit 0
EOF
sudo chmod +x "$NAT_SCRIPT"

sudo bash -c 'cat > /etc/systemd/system/dualnic-nat.service' <<'EOF'
[Unit]
Description=Restore dual-NIC NAT & forwarding for Docker
After=network-online.target docker.service
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/sbin/restore_dualnic_nat.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

sudo systemctl daemon-reload
sudo systemctl enable --now dualnic-nat.service

# ====== Pull & Run containers ======
echo "[INFO] Pull & Run containers..."
set +e

# traffmonetizer
timeout 300 docker pull traffmonetizer/cli_v2:latest
docker run -d --network my_network_1 --restart=always --name tm1 traffmonetizer/cli_v2:latest start accept --token JoaF9KjqyUjmIUCOMxx6W/6rKD0Q0XTHQ5zlqCEJlXM=
docker run -d --network my_network_2 --restart=always --name tm2 traffmonetizer/cli_v2:latest start accept --token JoaF9KjqyUjmIUCOMxx6W/6rKD0Q0XTHQ5zlqCEJlXM=

# repocket
timeout 300 docker pull repocket/repocket:latest
docker run --network my_network_1 --name repocket1 -e RP_EMAIL=nguyenvinhson000@gmail.com -e RP_API_KEY=cad6dcce-d038-4727-969b-d996ed80d3ef -d --restart=always repocket/repocket:latest
docker run --network my_network_2 --name repocket2 -e RP_EMAIL=nguyenvinhson000@gmail.com -e RP_API_KEY=cad6dcce-d038-4727-969b-d996ed80d3ef -d --restart=always repocket/repocket:latest

# myst: bind cổng vào IP nội bộ đúng NIC (GCP sẽ DNAT từ EIP -> IP nội bộ)
timeout 300 docker pull mysteriumnetwork/myst:latest
docker run -d --network my_network_1 --cap-add NET_ADMIN -p ${IP_A_INT}:4449:4449 --name myst1 -v myst-data1:/var/lib/mysterium-node --restart unless-stopped mysteriumnetwork/myst:latest service --agreed-terms-and-conditions
docker run -d --network my_network_2 --cap-add NET_ADMIN -p ${IP_B_INT}:4449:4449 --name myst2 -v myst-data2:/var/lib/mysterium-node --restart unless-stopped mysteriumnetwork/myst:latest service --agreed-terms-and-conditions

# earnfm
timeout 300 docker pull earnfm/earnfm-client:latest
docker run -d --network my_network_1 --restart=always -e EARNFM_TOKEN="50f04bbe-94d9-4f6a-82b9-b40016bd4bbb" --name earnfm1 earnfm/earnfm-client:latest
docker run -d --network my_network_2 --restart=always -e EARNFM_TOKEN="50f04bbe-94d9-4f6a-82b9-b40016bd4bbb" --name earnfm2 earnfm/earnfm-client:latest

# packetsdk
docker run -d --network my_network_1 --restart unless-stopped --name packetsdk1 packetsdk/packetsdk -appkey=BFwbNdFfwgcDdRmj
docker run -d --network my_network_2 --restart unless-stopped --name packetsdk2 packetsdk/packetsdk -appkey=BFwbNdFfwgcDdRmj

# urnetwork (amd64)
docker run -d --network my_network_1 --restart=always --platform linux/amd64 --cap-add NET_ADMIN --name ur1 -e USER_AUTH="nguyenvinhcao123@gmail.com" -e PASSWORD="CAOcao123CAO@" ghcr.io/techroy23/docker-urnetwork:latest
docker run -d --network my_network_2 --restart=always --platform linux/amd64 --cap-add NET_ADMIN --name ur2 -e USER_AUTH="nguyenvinhcao123@gmail.com" -e PASSWORD="CAOcao123CAO@" ghcr.io/techroy23/docker-urnetwork:latest

set -e

echo "[OK] Hoàn tất. Kiểm tra nhanh:"
ip -4 addr show "$ETH_A" | sed 's/^/  /'
ip -4 addr show "$ETH_B" | sed 's/^/  /'
sudo iptables -t nat -S POSTROUTING | sed 's/^/  /'
