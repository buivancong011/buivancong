#!/usr/bin/env bash
# install.sh — Multi-IP Docker stack for Amazon Linux 2023
# Features:
# - iptables SNAT runs FIRST (fail-fast). Bring-up runs 30s AFTER boot.
# - Auto-detect IP_A (noprefixroute) & IP_B (dynamic) on WAN_IFACE.
# - Auto-install Docker via yum/dnf if missing, enable & start, then reboot once.
# - Daily rolling restart (24h) sequential for repocket, earnfm, ur (delay between).
# - Weekly wipe (Sun 03:00): remove all containers & images (KEEP VOLUMES), reboot.
# - Optional crash-wipe mode (WIPE_ON_CRASH=1): if last shutdown was unclean → wipe at boot.
# - Idempotent, uses flock to avoid overlaps; fail-fast if iptables not OK.
set -Eeuo pipefail

### ---------- Config (override via env) ----------
WAN_IFACE="${WAN_IFACE:-ens5}"
NET1_NAME="${NET1_NAME:-my_network_1}"
NET2_NAME="${NET2_NAME:-my_network_2}"
NET1_CIDR="${NET1_CIDR:-192.168.33.0/24}"
NET2_CIDR="${NET2_CIDR:-192.168.34.0/24}"

DELAY_BETWEEN="${DELAY_BETWEEN:-60}"         # seconds between container operations
ROLLING_INTERVAL="${ROLLING_INTERVAL:-24h}"  # OnUnitActiveSec for rolling restart
WEEKLY_ONCALENDAR="${WEEKLY_ONCALENDAR:-Sun *-*-* 03:00:00}"
WIPE_ON_CRASH="${WIPE_ON_CRASH:-1}"          # 1=wipe containers+images on unclean reboot (keep volumes)

APP_DIR="/opt/multiip"
ENV_DIR="/etc/multiip"
ENV_FILE="${ENV_DIR}/multiip.env"
RUNTIME_DIR="/run/multiip"
LOCK_DIR="/run/lock"
STATE_DIR="/var/lib/multiip/state"
CLEAN_FLAG="${STATE_DIR}/clean_shutdown"

PATH="/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

### ---------- Utils ----------
log(){ printf "[%(%F %T)T] [INFO ] %s\n" -1 "$*"; }
warn(){ printf "[%(%F %T)T] [WARN ] %s\n" -1 "$*" >&2; }
err(){ printf "[%(%F %T)T] [ERROR] %s\n" -1 "$*" >&2; }
die(){ err "$*"; exit 1; }
trap 'err "Failure at line $LINENO (exit $?)"; exit 1' ERR

need_root(){
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    log "Re-exec with sudo..."
    exec sudo -E bash "$0" "$@"
  fi
}

ensure_dirs(){
  install -d "$APP_DIR" "$ENV_DIR" "$RUNTIME_DIR" "$LOCK_DIR" "$STATE_DIR"
}

### ---------- OS checks ----------
need_root "$@"
if [[ -r /etc/os-release ]]; then . /etc/os-release; else die "Cannot read /etc/os-release"; fi
if [[ "${ID:-}" != "amzn" || "${VERSION_ID:-}" != 2023* ]]; then
  warn "This script targets Amazon Linux 2023; detected ID=${ID:-?}, VERSION_ID=${VERSION_ID:-?}"
fi
ensure_dirs

### ---------- Secrets bootstrap ----------
# If /etc/multiip/multiip.env does not exist, try to build it from env vars provided in the one-liner
if [[ ! -f "$ENV_FILE" ]]; then
  if [[ -n "${TM_TOKEN:-}" || -n "${RP_EMAIL:-}" || -n "${RP_API_KEY:-}" || -n "${EARNFM_TOKEN:-}" || -n "${UR_USER_AUTH:-}" || -n "${UR_PASSWORD:-}" || -n "${PACKETSDK_APPKEY:-}" ]]; then
    cat >"$ENV_FILE" <<EOF
# auto-generated by install.sh
TM_TOKEN="${TM_TOKEN:-}"
RP_EMAIL="${RP_EMAIL:-}"
RP_API_KEY="${RP_API_KEY:-}"
EARNFM_TOKEN="${EARNFM_TOKEN:-}"
UR_USER_AUTH="${UR_USER_AUTH:-}"
UR_PASSWORD="${UR_PASSWORD:-}"
PACKETSDK_APPKEY="${PACKETSDK_APPKEY:-}"
WIPE_ON_CRASH="${WIPE_ON_CRASH:-1}"
WAN_IFACE="${WAN_IFACE:-ens5}"
NET1_NAME="${NET1_NAME:-my_network_1}"
NET2_NAME="${NET2_NAME:-my_network_2}"
NET1_CIDR="${NET1_CIDR:-192.168.33.0/24}"
NET2_CIDR="${NET2_CIDR:-192.168.34.0/24}"
DELAY_BETWEEN="${DELAY_BETWEEN:-60}"
ROLLING_INTERVAL="${ROLLING_INTERVAL:-24h}"
WEEKLY_ONCALENDAR="${WEEKLY_ONCALENDAR:-Sun *-*-* 03:00:00}"
EOF
    chmod 600 "$ENV_FILE"
    log "Wrote $ENV_FILE from environment variables."
  else
    cat >"$ENV_FILE" <<'EOF'
# Fill the secrets or pass via one-liner env:
TM_TOKEN=""
RP_EMAIL=""
RP_API_KEY=""
EARNFM_TOKEN=""
UR_USER_AUTH=""
UR_PASSWORD=""
PACKETSDK_APPKEY=""
WIPE_ON_CRASH="1"
WAN_IFACE="ens5"
NET1_NAME="my_network_1"
NET2_NAME="my_network_2"
NET1_CIDR="192.168.33.0/24"
NET2_CIDR="192.168.34.0/24"
DELAY_BETWEEN="60"
ROLLING_INTERVAL="24h"
WEEKLY_ONCALENDAR="Sun *-*-* 03:00:00"
EOF
    chmod 600 "$ENV_FILE"
    die "Created placeholder $ENV_FILE — fill it or run installer with env vars."
  fi
fi

### ---------- common.sh ----------
cat >"${APP_DIR}/common.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
log(){ printf "[%(%F %T)T] [INFO ] %s\n" -1 "$*"; }
warn(){ printf "[%(%F %T)T] [WARN ] %s\n" -1 "$*" >&2; }
err(){ printf "[%(%F %T)T] [ERROR] %s\n" -1 "$*" >&2; }
die(){ err "$*"; exit 1; }
PATH="/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

ENV_FILE="${ENV_FILE:-/etc/multiip/multiip.env}"
RUNTIME_DIR="${RUNTIME_DIR:-/run/multiip}"
LOCK_DIR="${LOCK_DIR:-/run/lock}"
STATE_DIR="${STATE_DIR:-/var/lib/multiip/state}"
CLEAN_FLAG="${CLEAN_FLAG:-/var/lib/multiip/state/clean_shutdown}"

# Load config & secrets
if [[ -f "$ENV_FILE" ]]; then set -a; source "$ENV_FILE"; set +a; fi

require_cmd(){ command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

ip_detect(){
  # A: noprefixroute (/32) - typically secondary private IP on AWS
  # B: dynamic - typically primary DHCP IP
  local want="$1" iface="${WAN_IFACE:-ens5}"
  case "$want" in
    A) ip -4 -o addr show dev "$iface" scope global noprefixroute | awk '{print $4}' | cut -d/ -f1 | head -n1 ;;
    B) ip -4 -o addr show dev "$iface" scope global dynamic      | awk '{print $4}' | cut -d/ -f1 | head -n1 ;;
    *) return 1 ;;
  esac
}

with_flock(){ # with_flock <lockname> <cmd...>
  local name="$1"; shift
  install -d "$LOCK_DIR"
  exec 9>"${LOCK_DIR}/${name}.lock"
  flock -n 9 || die "Another ${name} job is running"
  "$@"
}
EOF
chmod +x "${APP_DIR}/common.sh"

### ---------- apply_snat.sh (iptables FIRST & fail-fast) ----------
cat >"${APP_DIR}/apply_snat.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "iptables-snat" _main "$@"
exit 0

_main(){
  require_cmd ip
  command -v iptables >/dev/null 2>&1 || die "iptables not found"

  # Ensure kernel sysctls
  echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/99-ip_forward.conf
  sysctl -q -p /etc/sysctl.d/99-ip_forward.conf || die "sysctl ip_forward failed"
  modprobe br_netfilter >/dev/null 2>&1 || true
  sysctl -q net.bridge.bridge-nf-call-iptables=1 >/dev/null 2>&1 || true

  # NAT table availability
  iptables -t nat -S >/dev/null 2>&1 || die "iptables NAT table unavailable"

  local IP_A IP_B
  IP_A="$(ip_detect A)"; IP_B="$(ip_detect B)"
  [[ -n "$IP_A" ]] || die "Cannot detect IP_A (noprefixroute) on ${WAN_IFACE}"
  [[ -n "$IP_B" ]] || die "Cannot detect IP_B (dynamic) on ${WAN_IFACE}"

  install -d "$RUNTIME_DIR"
  cat >"${RUNTIME_DIR}/netvars.env" <<VARS
IP_A="${IP_A}"
IP_B="${IP_B}"
VARS

  # Insert SNAT rules at TOP (higher prio than Docker MASQUERADE)
  set +e
  iptables -w -t nat -C POSTROUTING -s "${NET1_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_A}" || \
  iptables -w -t nat -I POSTROUTING 1 -s "${NET1_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_A}"
  rc1=$?
  iptables -w -t nat -C POSTROUTING -s "${NET2_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_B}" || \
  iptables -w -t nat -I POSTROUTING 1 -s "${NET2_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_B}"
  rc2=$?
  set -e

  [[ $rc1 -eq 0 && $rc2 -eq 0 ]] || die "Failed to apply SNAT rules"

  log "SNAT OK: ${NET1_NAME}→${IP_A}, ${NET2_NAME}→${IP_B} (iface ${WAN_IFACE})"
}
EOF
chmod +x "${APP_DIR}/apply_snat.sh"

### ---------- bringup_stack.sh (30s after boot; verify internet) ----------
cat >"${APP_DIR}/bringup_stack.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh
set -a; [[ -f "${RUNTIME_DIR}/netvars.env" ]] && source "${RUNTIME_DIR}/netvars.env"; set +a

with_flock "bringup-stack" _main "$@"
exit 0

docker_present(){ command -v docker >/dev/null 2>&1; }

ensure_network(){
  local name="$1" cidr="$2"
  if ! docker network inspect "$name" >/dev/null 2>&1; then
    log "Creating docker network $name ($cidr)"
    docker network create "$name" --driver bridge --subnet "$cidr"
  else
    log "Network $name exists."
  fi
}

internet_test(){
  local net="$1"
  log "Testing internet on $net..."
  docker run --rm --network "$net" --pull never alpine:3.20 sh -c "wget -q --timeout=10 --spider http://example.com" \
    || die "Internet test failed on $net"
  log "Internet OK on $net."
}

run_or_restart(){
  # run_or_restart <name> <image> [args...]
  local name="$1" image="$2"; shift 2
  if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
    log "Container $name exists → ensuring it runs"
    docker start "$name" >/dev/null || true
    # normalize restart policy if provided in args
    if printf '%s ' "$@" | grep -q -- '--restart'; then
      local pol; pol="$(printf '%s ' "$@" | sed -n 's/.*--restart[= ]\([^ ]*\).*/\1/p')"
      [[ -n "$pol" ]] && docker update --restart "$pol" "$name" >/dev/null || true
    fi
  else
    log "Running new container $name"
    docker run -d --name "$name" "$image" "$@"
  fi
}

sleep_gap(){ sleep "${DELAY_BETWEEN}"; }

_main(){
  docker_present || die "Docker not found"
  [[ -f "${RUNTIME_DIR}/netvars.env" ]] || die "Missing ${RUNTIME_DIR}/netvars.env (iptables stage not done)"

  # Ensure networks
  ensure_network "${NET1_NAME}" "${NET1_CIDR}"
  ensure_network "${NET2_NAME}" "${NET2_CIDR}"

  # Internet tests
  internet_test "${NET1_NAME}"
  internet_test "${NET2_NAME}"

  # Pull images (non-fatal if fails)
  docker pull --quiet traffmonetizer/cli_v2:arm64v8 || true
  docker pull --quiet repocket/repocket:latest || true
  docker pull --quiet mysteriumnetwork/myst:latest || true
  docker pull --quiet earnfm/earnfm-client:latest || true
  docker pull --quiet packetsdk/packetsdk:latest || true
  docker pull --quiet ghcr.io/techroy23/docker-urnetwork:latest || true

  # Traffmonetizer
  run_or_restart "tm1" "traffmonetizer/cli_v2:arm64v8" --network "${NET1_NAME}" --restart always start accept --token "${TM_TOKEN}"
  sleep_gap
  run_or_restart "tm2" "traffmonetizer/cli_v2:arm64v8" --network "${NET2_NAME}" --restart always start accept --token "${TM_TOKEN}"
  sleep_gap

  # Repocket
  run_or_restart "repocket1" "repocket/repocket:latest" --network "${NET1_NAME}" --restart always -e "RP_EMAIL=${RP_EMAIL}" -e "RP_API_KEY=${RP_API_KEY}"
  sleep_gap
  run_or_restart "repocket2" "repocket/repocket:latest" --network "${NET2_NAME}" --restart always -e "RP_EMAIL=${RP_EMAIL}" -e "RP_API_KEY=${RP_API_KEY}"
  sleep_gap

  # Mysterium
  docker volume create myst-data1 >/dev/null || true
  docker volume create myst-data2 >/dev/null || true
  run_or_restart "myst1" "mysteriumnetwork/myst:latest" \
    --network "${NET1_NAME}" --cap-add NET_ADMIN -p "${IP_A}:4449:4449" \
    --restart unless-stopped -v myst-data1:/var/lib/mysterium-node service --agreed-terms-and-conditions
  sleep_gap
  run_or_restart "myst2" "mysteriumnetwork/myst:latest" \
    --network "${NET2_NAME}" --cap-add NET_ADMIN -p "${IP_B}:4449:4449" \
    --restart unless-stopped -v myst-data2:/var/lib/mysterium-node service --agreed-terms-and-conditions
  sleep_gap

  # EarnFM
  run_or_restart "earnfm1" "earnfm/earnfm-client:latest" --network "${NET1_NAME}" --restart always -e "EARNFM_TOKEN=${EARNFM_TOKEN}"
  sleep_gap
  run_or_restart "earnfm2" "earnfm/earnfm-client:latest" --network "${NET2_NAME}" --restart always -e "EARNFM_TOKEN=${EARNFM_TOKEN}"
  sleep_gap

  # PacketSDK
  run_or_restart "packetsdk1" "packetsdk/packetsdk:latest" --network "${NET1_NAME}" --restart unless-stopped -appkey="${PACKETSDK_APPKEY}"
  sleep_gap
  run_or_restart "packetsdk2" "packetsdk/packetsdk:latest" --network "${NET2_NAME}" --restart unless-stopped -appkey="${PACKETSDK_APPKEY}"
  sleep_gap

  # UR Network (arm64 platform)
  run_or_restart "ur1" "ghcr.io/techroy23/docker-urnetwork:latest" \
    --network "${NET1_NAME}" --restart always --platform linux/arm64 --cap-add NET_ADMIN -e "USER_AUTH=${UR_USER_AUTH}" -e "PASSWORD=${UR_PASSWORD}"
  sleep_gap
  run_or_restart "ur2" "ghcr.io/techroy23/docker-urnetwork:latest" \
    --network "${NET2_NAME}" --restart always --platform linux/arm64 --cap-add NET_ADMIN -e "USER_AUTH=${UR_USER_AUTH}" -e "PASSWORD=${UR_PASSWORD}"

  # Mark current boot as "dirty running" until a clean shutdown happens
  install -d "${STATE_DIR}"
  echo 0 > "${CLEAN_FLAG}" || true

  log "Bring-up complete."
}
EOF
chmod +x "${APP_DIR}/bringup_stack.sh"

### ---------- rolling_restart.sh (24h; sequential) ----------
cat >"${APP_DIR}/rolling_restart.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "rolling-restart" _main "$@"
exit 0

restart_one(){
  local name="$1"
  log "Restarting $name..."
  docker restart "$name" >/dev/null || die "Failed to restart $name"
  log "Restarted $name; waiting ${DELAY_BETWEEN}s"
  sleep "${DELAY_BETWEEN}"
}

_main(){
  require_cmd docker
  local order=(repocket1 earnfm1 ur1 repocket2 earnfm2 ur2)
  for c in "${order[@]}"; do
    if docker ps -a --format '{{.Names}}' | grep -qx "$c"; then
      restart_one "$c"
    else
      warn "Container $c not found; skipping."
    fi
  done
  log "Rolling restart done."
}
EOF
chmod +x "${APP_DIR}/rolling_restart.sh"

### ---------- weekly_wipe.sh (weekly; keep volumes; reboot) ----------
cat >"${APP_DIR}/weekly_wipe.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "weekly-wipe" _main "$@"
exit 0

_main(){
  require_cmd docker
  log "Stopping all containers..."
  docker stop $(docker ps -q) >/dev/null 2>&1 || true

  log "Removing all containers..."
  docker rm -f $(docker ps -aq) >/dev/null 2>&1 || true

  log "Removing all images (keeping volumes)..."
  docker rmi -f $(docker images -aq) >/dev/null 2>&1 || true
  docker system prune -af >/dev/null 2>&1 || true

  log "Marking clean shutdown and rebooting..."
  install -d "${STATE_DIR}"; echo 1 > "${CLEAN_FLAG}" || true
  systemctl reboot
}
EOF
chmod +x "${APP_DIR}/weekly_wipe.sh"

### ---------- boot_wipe.sh (wipe on unclean reboot; before bring-up) ----------
cat >"${APP_DIR}/boot_wipe.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "boot-wipe" _main "$@"
exit 0

_main(){
  set -a; [[ -f "${ENV_FILE}" ]] && source "${ENV_FILE}"; set +a
  [[ "${WIPE_ON_CRASH:-1}" == "1" ]] || { log "WIPE_ON_CRASH disabled"; echo 0 > "${CLEAN_FLAG}" || true; return; }

  require_cmd docker
  install -d "${STATE_DIR}"

  local last_clean=0
  [[ -f "${CLEAN_FLAG}" ]] && last_clean="$(cat "${CLEAN_FLAG}" || echo 0)"

  if [[ "${last_clean}" != "1" ]]; then
    warn "Detected unclean reboot → wiping containers & images (keep volumes)"
    docker stop $(docker ps -q) >/dev/null 2>&1 || true
    docker rm -f $(docker ps -aq) >/dev/null 2>&1 || true
    docker rmi -f $(docker images -aq) >/dev/null 2>&1 || true
    docker system prune -af >/dev/null 2>&1 || true
  else
    log "Previous shutdown was clean — no wipe."
  fi

  # Set running state to "dirty" until next clean shutdown
  echo 0 > "${CLEAN_FLAG}" || true
}
EOF
chmod +x "${APP_DIR}/boot_wipe.sh"

### ---------- mark_clean.sh (run at shutdown) ----------
cat >"${APP_DIR}/mark_clean.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh
install -d "${STATE_DIR}"
echo 1 > "${CLEAN_FLAG}" || true
log "Marked clean shutdown."
EOF
chmod +x "${APP_DIR}/mark_clean.sh"

### ---------- systemd units ----------
# 1) iptables first
cat >"/etc/systemd/system/iptables-snat.service" <<EOF
[Unit]
Description=Apply AWS SNAT rules (must run before Docker)
After=network-online.target
Wants=network-online.target
Before=docker.service multiip-boot-wipe.service multiip-stack.service

[Service]
Type=oneshot
ExecStart=${APP_DIR}/apply_snat.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# 2) boot wipe (if unclean reboot) — runs after iptables and docker, before bring-up
cat >"/etc/systemd/system/multiip-boot-wipe.service" <<EOF
[Unit]
Description=Wipe containers/images on unclean reboot (keep volumes)
After=iptables-snat.service docker.service
Requires=iptables-snat.service docker.service
Before=multiip-stack.service

[Service]
Type=oneshot
EnvironmentFile=-${ENV_FILE}
ExecStart=${APP_DIR}/boot_wipe.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# 3) bring-up after 30s
cat >"/etc/systemd/system/multiip-stack.service" <<EOF
[Unit]
Description=Bring up multi-IP Docker stack (after iptables + boot-wipe)
After=multiip-boot-wipe.service
Requires=multiip-boot-wipe.service

[Service]
Type=oneshot
EnvironmentFile=-${ENV_FILE}
ExecStartPre=/bin/sleep 30
ExecStart=${APP_DIR}/bringup_stack.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# 4) rolling restart (every 24h)
cat >"/etc/systemd/system/rolling-restart.service" <<EOF
[Unit]
Description=Rolling restart (repocket/earnfm/ur) sequential with delay
After=multiip-stack.service
Requires=multiip-stack.service

[Service]
Type=oneshot
EnvironmentFile=-${ENV_FILE}
ExecStart=${APP_DIR}/rolling_restart.sh
EOF

cat >"/etc/systemd/system/rolling-restart.timer" <<EOF
[Unit]
Description=Every 24 hours rolling restart timer

[Timer]
OnUnitActiveSec=${ROLLING_INTERVAL}
RandomizedDelaySec=120
Unit=rolling-restart.service

[Install]
WantedBy=timers.target
EOF

# 5) weekly wipe (Sun 03:00)
cat >"/etc/systemd/system/weekly-wipe.service" <<EOF
[Unit]
Description=Weekly wipe (remove containers & images, keep volumes) then reboot
After=multiip-stack.service
Requires=multiip-stack.service

[Service]
Type=oneshot
ExecStart=${APP_DIR}/weekly_wipe.sh
TimeoutStartSec=0
EOF

cat >"/etc/systemd/system/weekly-wipe.timer" <<EOF
[Unit]
Description=Weekly wipe timer (Sun 03:00 local time)

[Timer]
OnCalendar=${WEEKLY_ONCALENDAR}
RandomizedDelaySec=300
Unit=weekly-wipe.service

[Install]
WantedBy=timers.target
EOF

# 6) mark clean shutdown (runs at shutdown only)
cat >"/etc/systemd/system/multiip-mark-clean.service" <<EOF
[Unit]
Description=Mark clean shutdown for multiip
DefaultDependencies=no
Before=shutdown.target

[Service]
Type=oneshot
ExecStart=${APP_DIR}/mark_clean.sh

[Install]
WantedBy=shutdown.target
EOF

### ---------- package ops: remove unwanted, install Docker/iptables ----------
new_docker=0

remove_if_present(){
  local pkg="$1"
  if rpm -q "$pkg" >/dev/null 2>&1; then
    log "Removing package: $pkg"
    yum -y remove "$pkg" || true
  fi
}

install_pkg(){
  local pkg="$1"
  if ! rpm -q "$pkg" >/dev/null 2>&1; then
    log "Installing package: $pkg"
    yum -y install "$pkg" || dnf -y install "$pkg"
  fi
}

remove_if_present squid
remove_if_present httpd-tools
install_pkg iptables

if ! command -v docker >/dev/null 2>&1; then
  log "Docker not found — installing via yum..."
  if yum -y install docker; then
    new_docker=1
  else
    warn "yum install docker failed; trying dnf..."
    dnf -y install docker || die "Failed to install docker via yum/dnf. Check repos."
    new_docker=1
  fi
fi

### ---------- Enable services & timers ----------
log "Reloading systemd units..."
systemctl daemon-reload

log "Enabling iptables-snat, boot-wipe, bring-up, mark-clean"
systemctl enable iptables-snat.service
systemctl enable multiip-boot-wipe.service
systemctl enable multiip-stack.service
systemctl enable multiip-mark-clean.service

log "Enabling timers (rolling restart & weekly wipe)"
systemctl enable rolling-restart.timer
systemctl enable weekly-wipe.timer

if [[ $new_docker -eq 1 ]]; then
  log "Enabling & starting docker, then performing a one-time reboot..."
  systemctl enable --now docker
  systemctl start rolling-restart.timer
  systemctl start weekly-wipe.timer
  # First boot after docker install → reboot to cleanly apply the chain
  systemctl reboot
  exit 0
fi

# If docker already present: start services & timers right away
systemctl start iptables-snat.service
systemctl start docker.service
systemctl start multiip-boot-wipe.service
systemctl start multiip-stack.service
systemctl start rolling-restart.timer
systemctl start weekly-wipe.timer

log "Installation finished. Stack is coming up."
