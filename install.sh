#!/usr/bin/env bash
# install.sh — Multi-IP Docker stack for Amazon Linux 2023 (one-shot installer)
# - Installs Docker with yum if missing, removes squid/httpd-tools, and reboots once
# - Ensures iptables SNAT rules applied FIRST at boot (fail-fast)
# - Brings up docker networks + your containers after 30s
# - Rolling restart (24h) for repocket/earnfm/ur (sequential with delays)
# - Weekly wipe (Sun 03:00 local time): remove containers & images (keep volumes), then reboot
# - Fully idempotent; uses flock to avoid overlaps
set -Eeuo pipefail

### ---------- Config (edit if needed) ----------
WAN_IFACE="${WAN_IFACE:-ens5}"
NET1_NAME="${NET1_NAME:-my_network_1}"
NET2_NAME="${NET2_NAME:-my_network_2}"
NET1_CIDR="${NET1_CIDR:-192.168.33.0/24}"
NET2_CIDR="${NET2_CIDR:-192.168.34.0/24}"
DELAY_BETWEEN="${DELAY_BETWEEN:-60}"      # seconds between sequential container ops
ROLLING_INTERVAL="${ROLLING_INTERVAL:-24h}"
WEEKLY_ONCALENDAR="${WEEKLY_ONCALENDAR:-Sun *-*-* 03:00:00}"
APP_DIR="/opt/multiip"
ENV_DIR="/etc/multiip"
ENV_FILE="${ENV_DIR}/multiip.env"
RUNTIME_DIR="/run/multiip"
LOCK_DIR="/run/lock"
PATH="/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

### ---------- Utils ----------
log(){ printf "[%(%F %T)T] [INFO ] %s\n" -1 "$*"; }
warn(){ printf "[%(%F %T)T] [WARN ] %s\n" -1 "$*" >&2; }
err(){ printf "[%(%F %T)T] [ERROR] %s\n" -1 "$*" >&2; }
die(){ err "$*"; exit 1; }
trap 'err "Failure at line $LINENO (exit $?)"; exit 1' ERR

need_root(){
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    log "Re-exec with sudo..."
    exec sudo -E bash "$0" "$@"
  fi
}

ensure_dirs(){
  install -d "$APP_DIR" "$ENV_DIR" "$RUNTIME_DIR" "$LOCK_DIR"
}

write_file(){ # write_file <path> <content>
  local path="$1"; shift
  umask 022
  cat >"$path" <<'EOF'
CONTENT_PLACEHOLDER
EOF
  # Replace placeholder marker with caller-provided content (preserve quotes/newlines)
  # shellcheck disable=SC2016
  sed -i '1,/^CONTENT_PLACEHOLDER$/d' "$path"
  # This function is used via here-doc injections below (we won't actually call it directly)
  :
}

### ---------- OS checks ----------
need_root "$@"
if [[ -r /etc/os-release ]]; then . /etc/os-release; else die "Cannot read /etc/os-release"; fi
if [[ "${ID:-}" != "amzn" || "${VERSION_ID:-}" != 2023* ]]; then
  warn "This script targets Amazon Linux 2023; detected ID=${ID:-?}, VERSION_ID=${VERSION_ID:-?}"
fi

ensure_dirs

### ---------- Secrets bootstrap ----------
# Allow one-liner with env vars to generate /etc/multiip/multiip.env if absent
if [[ ! -f "$ENV_FILE" ]]; then
  log "Secrets file not found: $ENV_FILE"
  if [[ -n "${TM_TOKEN:-}" || -n "${RP_EMAIL:-}" || -n "${RP_API_KEY:-}" || -n "${EARNFM_TOKEN:-}" || -n "${UR_USER_AUTH:-}" || -n "${UR_PASSWORD:-}" || -n "${PACKETSDK_APPKEY:-}" ]]; then
    cat >"$ENV_FILE" <<EOF
# --- auto-generated by install.sh ---
TM_TOKEN="${TM_TOKEN:-}"
RP_EMAIL="${RP_EMAIL:-}"
RP_API_KEY="${RP_API_KEY:-}"
EARNFM_TOKEN="${EARNFM_TOKEN:-}"
UR_USER_AUTH="${UR_USER_AUTH:-}"
UR_PASSWORD="${UR_PASSWORD:-}"
PACKETSDK_APPKEY="${PACKETSDK_APPKEY:-}"
EOF
    chmod 600 "$ENV_FILE"
    log "Wrote $ENV_FILE from environment variables."
  else
    cat >"$ENV_FILE" <<'EOF'
# Fill these before (re)running the installer, or export them inline with the one-liner:
#   TM_TOKEN="..." RP_EMAIL="..." RP_API_KEY="..." EARNFM_TOKEN="..." \
#   UR_USER_AUTH="..." UR_PASSWORD="..." PACKETSDK_APPKEY="..." bash -c "$(curl -fsSL .../install.sh)"
TM_TOKEN=""
RP_EMAIL=""
RP_API_KEY=""
EARNFM_TOKEN=""
UR_USER_AUTH=""
UR_PASSWORD=""
PACKETSDK_APPKEY=""
EOF
    chmod 600 "$ENV_FILE"
    err "Created placeholder $ENV_FILE. Please edit with your secrets, then rerun this installer."
    exit 1
  fi
fi

### ---------- Write common.sh ----------
cat >"${APP_DIR}/common.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
log(){ printf "[%(%F %T)T] [INFO ] %s\n" -1 "$*"; }
warn(){ printf "[%(%F %T)T] [WARN ] %s\n" -1 "$*" >&2; }
err(){ printf "[%(%F %T)T] [ERROR] %s\n" -1 "$*" >&2; }
die(){ err "$*"; exit 1; }
PATH="/usr/sbin:/usr/bin:/sbin:/bin:$PATH"

WAN_IFACE="${WAN_IFACE:-ens5}"
NET1_NAME="${NET1_NAME:-my_network_1}"
NET2_NAME="${NET2_NAME:-my_network_2}"
NET1_CIDR="${NET1_CIDR:-192.168.33.0/24}"
NET2_CIDR="${NET2_CIDR:-192.168.34.0/24}"
DELAY_BETWEEN="${DELAY_BETWEEN:-60}"
ENV_FILE="${ENV_FILE:-/etc/multiip/multiip.env}"
RUNTIME_DIR="${RUNTIME_DIR:-/run/multiip}"
LOCK_DIR="${LOCK_DIR:-/run/lock}"

# Load secrets if present
if [[ -f "$ENV_FILE" ]]; then set -a; source "$ENV_FILE"; set +a; fi

require_cmd(){ command -v "$1" >/dev/null 2>&1 || die "Missing command: $1"; }

ip_detect(){
  local want="$1"   # "A" or "B"
  # A: noprefixroute (/32) — typically the secondary private IP on AWS
  # B: dynamic           — typically the primary DHCP IP on AWS
  case "$want" in
    A) ip -4 -o addr show dev "$WAN_IFACE" scope global noprefixroute | awk '{print $4}' | cut -d/ -f1 | head -n1 ;;
    B) ip -4 -o addr show dev "$WAN_IFACE" scope global dynamic      | awk '{print $4}' | cut -d/ -f1 | head -n1 ;;
    *) return 1 ;;
  esac
}

with_flock(){ # with_flock <lockname> <command...>
  local name="$1"; shift
  install -d "$LOCK_DIR"
  exec 9>"${LOCK_DIR}/${name}.lock"
  flock -n 9 || die "Another ${name} job is running"
  "$@"
}
EOF
chmod +x "${APP_DIR}/common.sh"

### ---------- Write apply_snat.sh (iptables FIRST & fail-fast) ----------
cat >"${APP_DIR}/apply_snat.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "iptables-snat" _main "$@"
exit 0

_main(){
  require_cmd ip
  # Prefer iptables (nft backend) on AL2023
  if ! command -v iptables >/dev/null 2>&1; then
    die "iptables not found"
  fi

  # Enable forward (persist)
  echo "net.ipv4.ip_forward=1" > /etc/sysctl.d/99-ip_forward.conf
  sysctl -q -p /etc/sysctl.d/99-ip_forward.conf || die "sysctl ip_forward failed"

  # Quick sanity: NAT table exists?
  iptables -t nat -S >/dev/null 2>&1 || die "iptables nat table unavailable"

  local IP_A IP_B
  IP_A="$(ip_detect A)"; IP_B="$(ip_detect B)"
  [[ -n "$IP_A" ]] || die "Cannot detect IP_A (noprefixroute) on ${WAN_IFACE}"
  [[ -n "$IP_B" ]] || die "Cannot detect IP_B (dynamic) on ${WAN_IFACE}"

  # Write for other scripts
  install -d "$RUNTIME_DIR"
  cat >"${RUNTIME_DIR}/netvars.env" <<VARS
IP_A="${IP_A}"
IP_B="${IP_B}"
VARS

  # Insert SNAT rules at top (prioritize over Docker MASQUERADE)
  # Use -w to wait for xtables lock and -C to avoid duplicates
  set +e
  iptables -w -t nat -C POSTROUTING -s "${NET1_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_A}" || \
  iptables -w -t nat -I POSTROUTING 1 -s "${NET1_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_A}"
  rc1=$?

  iptables -w -t nat -C POSTROUTING -s "${NET2_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_B}" || \
  iptables -w -t nat -I POSTROUTING 1 -s "${NET2_CIDR}" -o "${WAN_IFACE}" -j SNAT --to-source "${IP_B}"
  rc2=$?
  set -e

  [[ $rc1 -eq 0 && $rc2 -eq 0 ]] || die "Failed to apply SNAT rules"

  log "SNAT OK: ${NET1_NAME}→${IP_A}, ${NET2_NAME}→${IP_B} (iface ${WAN_IFACE})"
}
EOF
chmod +x "${APP_DIR}/apply_snat.sh"

### ---------- Write bringup_stack.sh (30s after boot; verify internet) ----------
cat >"${APP_DIR}/bringup_stack.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh
set -a; [[ -f "${RUNTIME_DIR}/netvars.env" ]] && source "${RUNTIME_DIR}/netvars.env"; set +a

with_flock "bringup-stack" _main "$@"
exit 0

docker_present(){ command -v docker >/dev/null 2>&1; }

ensure_network(){
  local name="$1" cidr="$2"
  if ! docker network inspect "$name" >/dev/null 2>&1; then
    log "Creating docker network $name ($cidr)"
    docker network create "$name" --driver bridge --subnet "$cidr"
  else
    log "Network $name exists."
  fi
}

internet_test(){
  local net="$1"
  log "Testing internet on $net..."
  docker run --rm --network "$net" --pull never alpine:3.20 sh -c \
    "wget -q --timeout=10 --spider http://example.com" \
    || die "Internet test failed on $net"
  log "Internet OK on $net."
}

run_or_restart(){
  # run_or_restart <name> <image> [args...]
  local name="$1" image="$2"; shift 2
  if docker ps -a --format '{{.Names}}' | grep -qx "$name"; then
    log "Container $name exists → ensuring it runs"
    docker start "$name" >/dev/null || true
    # normalize restart policy if provided in args
    if printf '%s ' "$@" | grep -q -- '--restart'; then
      local pol; pol="$(printf '%s ' "$@" | sed -n 's/.*--restart[= ]\([^ ]*\).*/\1/p')"
      [[ -n "$pol" ]] && docker update --restart "$pol" "$name" >/dev/null || true
    fi
  else
    log "Running new container $name"
    docker run -d --name "$name" "$image" "$@"
  fi
}

sleep_gap(){ sleep "${DELAY_BETWEEN}"; }

_main(){
  docker_present || die "Docker not found"
  [[ -f "${RUNTIME_DIR}/netvars.env" ]] || die "Missing ${RUNTIME_DIR}/netvars.env (iptables stage not done)"

  # Ensure networks
  ensure_network "${NET1_NAME}" "${NET1_CIDR}"
  ensure_network "${NET2_NAME}" "${NET2_CIDR}"

  # Internet tests per network (ensures SNAT is effective)
  internet_test "${NET1_NAME}"
  internet_test "${NET2_NAME}"

  # ---------- Containers ----------
  # Pull base images (non-blocking if already present)
  docker pull --quiet traffmonetizer/cli_v2:arm64v8 || true
  docker pull --quiet repocket/repocket:latest || true
  docker pull --quiet mysteriumnetwork/myst:latest || true
  docker pull --quiet earnfm/earnfm-client:latest || true
  docker pull --quiet packetsdk/packetsdk:latest || true
  docker pull --quiet ghcr.io/techroy23/docker-urnetwork:latest || true

  # Traffmonetizer
  run_or_restart "tm1" "traffmonetizer/cli_v2:arm64v8" --network "${NET1_NAME}" --restart always start accept --token "${TM_TOKEN}"
  sleep_gap
  run_or_restart "tm2" "traffmonetizer/cli_v2:arm64v8" --network "${NET2_NAME}" --restart always start accept --token "${TM_TOKEN}"
  sleep_gap

  # Repocket
  run_or_restart "repocket1" "repocket/repocket:latest" --network "${NET1_NAME}" --restart always -e "RP_EMAIL=${RP_EMAIL}" -e "RP_API_KEY=${RP_API_KEY}"
  sleep_gap
  run_or_restart "repocket2" "repocket/repocket:latest" --network "${NET2_NAME}" --restart always -e "RP_EMAIL=${RP_EMAIL}" -e "RP_API_KEY=${RP_API_KEY}"
  sleep_gap

  # Mysterium (bind to IP_A/IP_B port 4449)
  docker volume create myst-data1 >/dev/null || true
  docker volume create myst-data2 >/dev/null || true
  run_or_restart "myst1" "mysteriumnetwork/myst:latest" \
    --network "${NET1_NAME}" --cap-add NET_ADMIN -p "${IP_A}:4449:4449" \
    --restart unless-stopped -v myst-data1:/var/lib/mysterium-node service --agreed-terms-and-conditions
  sleep_gap
  run_or_restart "myst2" "mysteriumnetwork/myst:latest" \
    --network "${NET2_NAME}" --cap-add NET_ADMIN -p "${IP_B}:4449:4449" \
    --restart unless-stopped -v myst-data2:/var/lib/mysterium-node service --agreed-terms-and-conditions
  sleep_gap

  # EarnFM
  run_or_restart "earnfm1" "earnfm/earnfm-client:latest" --network "${NET1_NAME}" --restart always -e "EARNFM_TOKEN=${EARNFM_TOKEN}"
  sleep_gap
  run_or_restart "earnfm2" "earnfm/earnfm-client:latest" --network "${NET2_NAME}" --restart always -e "EARNFM_TOKEN=${EARNFM_TOKEN}"
  sleep_gap

  # PacketSDK
  run_or_restart "packetsdk1" "packetsdk/packetsdk:latest" --network "${NET1_NAME}" --restart unless-stopped -appkey="${PACKETSDK_APPKEY}"
  sleep_gap
  run_or_restart "packetsdk2" "packetsdk/packetsdk:latest" --network "${NET2_NAME}" --restart unless-stopped -appkey="${PACKETSDK_APPKEY}"
  sleep_gap

  # UR Network (arm64 platform)
  run_or_restart "ur1" "ghcr.io/techroy23/docker-urnetwork:latest" \
    --network "${NET1_NAME}" --restart always --platform linux/arm64 --cap-add NET_ADMIN -e "USER_AUTH=${UR_USER_AUTH}" -e "PASSWORD=${UR_PASSWORD}"
  sleep_gap
  run_or_restart "ur2" "ghcr.io/techroy23/docker-urnetwork:latest" \
    --network "${NET2_NAME}" --restart always --platform linux/arm64 --cap-add NET_ADMIN -e "USER_AUTH=${UR_USER_AUTH}" -e "PASSWORD=${UR_PASSWORD}"

  log "Bring-up complete."
}
EOF
chmod +x "${APP_DIR}/bringup_stack.sh"

### ---------- Write rolling_restart.sh (every 24h, sequential) ----------
cat >"${APP_DIR}/rolling_restart.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "rolling-restart" _main "$@"
exit 0

restart_one(){
  local name="$1"
  log "Restarting $name..."
  docker restart "$name" >/dev/null || die "Failed to restart $name"
  log "Restarted $name; waiting ${DELAY_BETWEEN}s"
  sleep "${DELAY_BETWEEN}"
}

_main(){
  require_cmd docker
  # Only the requested apps: repocket, earnfm, ur (1 then 2, to spread load)
  local order=(repocket1 earnfm1 ur1 repocket2 earnfm2 ur2)
  for c in "${order[@]}"; do
    if docker ps -a --format '{{.Names}}' | grep -qx "$c"; then
      restart_one "$c"
    else
      warn "Container $c not found; skipping."
    fi
  done
  log "Rolling restart done."
}
EOF
chmod +x "${APP_DIR}/rolling_restart.sh"

### ---------- Write weekly_wipe.sh (weekly; keep volumes; reboot) ----------
cat >"${APP_DIR}/weekly_wipe.sh" <<"EOF"
#!/usr/bin/env bash
set -Eeuo pipefail
source /opt/multiip/common.sh

with_flock "weekly-wipe" _main "$@"
exit 0

_main(){
  require_cmd docker
  log "Stopping all containers..."
  docker stop $(docker ps -q) >/dev/null 2>&1 || true

  log "Removing all containers..."
  docker rm -f $(docker ps -aq) >/dev/null 2>&1 || true

  log "Removing all images (keeping volumes)..."
  docker rmi -f $(docker images -aq) >/dev/null 2>&1 || true
  docker system prune -af >/dev/null 2>&1 || true

  log "Weekly wipe complete. Rebooting..."
  systemctl reboot
}
EOF
chmod +x "${APP_DIR}/weekly_wipe.sh"

### ---------- Systemd units ----------
# iptables first
cat >"/etc/systemd/system/iptables-snat.service" <<EOF
[Unit]
Description=Apply AWS SNAT rules (must run before Docker)
After=network-online.target
Wants=network-online.target
Before=docker.service multiip-stack.service

[Service]
Type=oneshot
ExecStart=${APP_DIR}/apply_snat.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# Bring-up after 30s
cat >"/etc/systemd/system/multiip-stack.service" <<EOF
[Unit]
Description=Bring up multi-IP Docker stack (after iptables)
After=iptables-snat.service docker.service
Requires=iptables-snat.service docker.service

[Service]
Type=oneshot
EnvironmentFile=-${ENV_FILE}
ExecStartPre=/bin/sleep 30
ExecStart=${APP_DIR}/bringup_stack.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# Rolling restart (every 24h)
cat >"/etc/systemd/system/rolling-restart.service" <<EOF
[Unit]
Description=Rolling restart (repocket/earnfm/ur) sequential with delay
After=multiip-stack.service
Requires=multiip-stack.service

[Service]
Type=oneshot
EnvironmentFile=-${ENV_FILE}
ExecStart=${APP_DIR}/rolling_restart.sh
EOF

cat >"/etc/systemd/system/rolling-restart.timer" <<EOF
[Unit]
Description=Every 24 hours rolling restart timer

[Timer]
OnUnitActiveSec=${ROLLING_INTERVAL}
RandomizedDelaySec=120
Unit=rolling-restart.service

[Install]
WantedBy=timers.target
EOF

# Weekly wipe (Sun 03:00)
cat >"/etc/systemd/system/weekly-wipe.service" <<EOF
[Unit]
Description=Weekly wipe (remove containers & images, keep volumes) then reboot
After=multiip-stack.service
Requires=multiip-stack.service

[Service]
Type=oneshot
ExecStart=${APP_DIR}/weekly_wipe.sh
TimeoutStartSec=0
EOF

cat >"/etc/systemd/system/weekly-wipe.timer" <<EOF
[Unit]
Description=Weekly wipe timer (Sun 03:00 local time)

[Timer]
OnCalendar=${WEEKLY_ONCALENDAR}
RandomizedDelaySec=300
Unit=weekly-wipe.service

[Install]
WantedBy=timers.target
EOF

### ---------- Package ops: remove unwanted, install Docker/iptables ----------
new_docker=0

remove_if_present(){
  local pkg="$1"
  if rpm -q "$pkg" >/dev/null 2>&1; then
    log "Removing package: $pkg"
    yum -y remove "$pkg" || true
  fi
}

install_pkg(){
  local pkg="$1"
  if ! rpm -q "$pkg" >/dev/null 2>&1; then
    log "Installing package: $pkg"
    yum -y install "$pkg" || dnf -y install "$pkg"
  fi
}

remove_if_present squid
remove_if_present httpd-tools
install_pkg iptables

if ! command -v docker >/dev/null 2>&1; then
  log "Docker not found — installing via yum..."
  if yum -y install docker; then
    new_docker=1
  else
    warn "yum install docker failed; trying dnf..."
    dnf -y install docker || die "Failed to install docker via yum/dnf. Make sure 'docker' is available on AL2023 repos."
    new_docker=1
  fi
fi

### ---------- Enable services & timers ----------
log "Reloading systemd units..."
systemctl daemon-reload

log "Enabling iptables-snat & multiip-stack services"
systemctl enable iptables-snat.service
systemctl enable multiip-stack.service

log "Enabling timers (rolling restart & weekly wipe)"
systemctl enable rolling-restart.timer
systemctl enable weekly-wipe.timer

# Docker enable + start now
if [[ $new_docker -eq 1 ]]; then
  log "Enabling & starting docker, then performing a one-time reboot..."
  systemctl enable --now docker
  # Start timers so they survive reboot
  systemctl start rolling-restart.timer
  systemctl start weekly-wipe.timer
  # First boot after docker install → reboot to cleanly apply chain (per your requirement)
  systemctl reboot
  exit 0
fi

# If docker already present: start things immediately
systemctl start iptables-snat.service
systemctl start docker.service
systemctl start multiip-stack.service
systemctl start rolling-restart.timer
systemctl start weekly-wipe.timer

log "Installation finished. Stack is coming up."
